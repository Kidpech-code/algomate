# ЁЯМР р╕Др╕╣р╣Ир╕бр╕╖р╕н Graph Algorithms р╕Вр╕нр╕З AlgoMate р╕Йр╕Ър╕▒р╕Ър╕кр╕бр╕Ър╕╣р╕гр╕Ур╣М

**р╕Др╕╣р╣Ир╕бр╕╖р╕нр╕Др╕гр╕Ър╕Др╕гр╕▒р╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╣Гр╕Щ AlgoMate - р╕Хр╕▒р╣Йр╕Зр╣Бр╕Хр╣Ир╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕Зр╕Бр╕гр╕▓р╕Яр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щр╣Др╕Ыр╕Ир╕Щр╕Цр╕╢р╕Зр╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З**

## ЁЯУЦ р╕кр╕▓р╕гр╕Ър╕▒р╕Н

- [ЁЯОп р╕ар╕▓р╕Юр╕гр╕зр╕б](#-р╕ар╕▓р╕Юр╕гр╕зр╕б)
- [ЁЯПЧя╕П р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е Graph](#я╕П-р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е-graph)
- [ЁЯЪ╢ р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕Зр╕Бр╕гр╕▓р╕Я](#-р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕Зр╕Бр╕гр╕▓р╕Я)
- [ЁЯЧ║я╕П р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Ф](#я╕П-р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Ф)
- [ЁЯМ│ р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Minimum Spanning Tree](#-р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б-minimum-spanning-tree)
- [ЁЯФм р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З](#-р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б-graph-р╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З)
- [ЁЯОо р╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕Зр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Ир╕гр╕┤р╕З](#-р╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕Зр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Ир╕гр╕┤р╕З)
- [тЪб р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю](#-р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю)
- [ЁЯзк р╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╣Бр╕ер╕░р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ](#-р╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╣Бр╕ер╕░р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ)

## ЁЯОп р╕ар╕▓р╕Юр╕гр╕зр╕б

AlgoMate р╕бр╕╡р╕Кр╕╕р╕Фр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╕Чр╕╡р╣Ир╕Др╕гр╕Ър╕Др╕гр╕▒р╕Щ **р╕Бр╕зр╣Ир╕▓ 10+ р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б** р╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕бр╕Др╕зр╕▓р╕бр╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕е Graph р╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф:

### тЬЕ **р╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕бр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Чр╕╕р╕Бр╕Ыр╕гр╕░р╣Ар╕ар╕Ч**

| р╕лр╕бр╕зр╕Фр╕лр╕бр╕╣р╣И                  | р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б                               | Time Complexity            | р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ                               |
| ------------------------- | ---------------------------------------- | -------------------------- | --------------------------------------- |
| **р╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕Зр╕Бр╕гр╕▓р╕Я**           | BFS, DFS                                 | O(V + E)                   | р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕З, р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╕Бр╕▓р╕гр╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕н          |
| **р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Ф**        | Dijkstra, Bellman-Ford, Floyd-Warshall   | O((V+E)logV), O(VE), O(V┬│) | р╕гр╕░р╕Ър╕Ъ GPS, р╕Бр╕▓р╕гр╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕З                  |
| **Minimum Spanning Tree** | Prim's, Kruskal's                        | O((V+E)logV), O(ElogE)     | р╕Бр╕▓р╕гр╕нр╕нр╕Бр╣Бр╕Ър╕Ър╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕в, р╕Бр╕▓р╕гр╕Ир╕▒р╕Фр╕Бр╕ер╕╕р╣Ир╕б         |
| **р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З**   | Topological Sort, SCC (Kosaraju, Tarjan) | O(V + E)                   | р╕Бр╕▓р╕гр╕Ир╕▒р╕Фр╕Хр╕▓р╕гр╕▓р╕Зр╕Зр╕▓р╕Щ, р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М dependency |

### ЁЯОк **р╕Др╕╕р╕Ур╕кр╕бр╕Ър╕▒р╕Хр╕┤р╕лр╕ер╕▒р╕Б**

- **ЁЯзм р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Generic**: р╣Гр╕Кр╣Йр╣Др╕Фр╣Йр╕Бр╕▒р╕Ър╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Гр╕Фр╕Бр╣Зр╣Др╕Фр╣Й `T`
- **ЁЯПЧя╕П Strategy Pattern**: р╕кр╕нр╕Фр╕Др╕ер╣Йр╕нр╕Зр╕Бр╕▒р╕Ър╕кр╕Цр╕▓р╕Ыр╕▒р╕Хр╕вр╕Бр╕гр╕гр╕б AlgoMate
- **тЪб р╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Юр╕кр╕╣р╕З**: р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Чр╕╡р╣Ир╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╣Бр╕ер╣Йр╕зр╕Фр╣Йр╕зр╕в complexity р╕Хр╕▒р╣Йр╕Зр╣Бр╕Хр╣И O(V + E) р╕Цр╕╢р╕З O(V┬│)
- **ЁЯФз р╕Бр╕▓р╕гр╕гр╕зр╕бр╣Ар╕Вр╣Йр╕▓р╕Зр╣Ир╕▓р╕в**: р╕Чр╕Фр╣Бр╕Чр╕Щр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Graph р╣Бр╕Ър╕Ър╕Бр╕│р╕лр╕Щр╕Фр╣Ар╕нр╕Зр╣Др╕Фр╣Й
- **ЁЯУК р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Чр╕╡р╣Ир╕лр╕ер╕▓р╕Бр╕лр╕ер╕▓р╕в**: р╕зр╕▒р╕Хр╕Цр╕╕р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Чр╕╡р╣Ир╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕бр╕Юр╕гр╣Йр╕нр╕бр╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕З, р╕гр╕░р╕вр╕░р╕Чр╕▓р╕З, р╣Бр╕ер╕░р╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕бр╕Хр╕▓

## ЁЯПЧя╕П р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е Graph

### р╕Др╕ер╕▓р╕к Graph<T>

р╕Бр╕▓р╕гр╣Бр╕кр╕Фр╕Зр╕Бр╕гр╕▓р╕Яр╕лр╕ер╕▒р╕Бр╣Вр╕Фр╕вр╣Гр╕Кр╣Й adjacency lists:

```dart
// р╕кр╕гр╣Йр╕▓р╕З Graph р╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Хр╣Ир╕▓р╕Зр╣Ж
final undirectedGraph = Graph<String>(isDirected: false);
final directedWeightedGraph = Graph<String>(isDirected: true, isWeighted: true);

// р╣Ар╕Юр╕┤р╣Ир╕бр╕Ир╕╕р╕Фр╕вр╕нр╕Ф (vertices) р╣Бр╕ер╕░р╣Ар╕кр╣Йр╕Щр╣Ар╕Кр╕╖р╣Ир╕нр╕б (edges)
graph.addVertex('A');
graph.addVertex('B');
graph.addEdge('A', 'B', weight: 10.0); // weight р╣Ар╕Ыр╣Зр╕Щ optional р╕кр╕│р╕лр╕гр╕▒р╕Ъ unweighted graphs
```

### р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕Щр╕▒р╕Ър╕кр╕Щр╕╕р╕Щ

#### Edge<T> р╣Бр╕ер╕░ GraphEdge<T>

```dart
class Edge<T> {
  final T destination;
  final double weight;
  const Edge(this.destination, [this.weight = 1.0]);
}

class GraphEdge<T> {
  final T source;
  final T destination;
  final double weight;
  const GraphEdge(this.source, this.destination, [this.weight = 1.0]);
}
```

#### UnionFind<T> (р╕кр╕│р╕лр╕гр╕▒р╕Ъ MST algorithms)

```dart
class UnionFind<T> {
  final Map<T, T> _parent = {};
  final Map<T, int> _rank = {};

  T find(T element) { /* ... */ }
  void union(T a, T b) { /* ... */ }
  bool connected(T a, T b) => find(a) == find(b);
}
```

## ЁЯЪ╢ р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕Зр╕Бр╕гр╕▓р╕Я

### Breadth-First Search (BFS)

**р╣Ар╕лр╕бр╕▓р╕░р╕кр╕│р╕лр╕гр╕▒р╕Ъ**: р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Фр╣Гр╕Щ unweighted graphs, р╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕Зр╣Бр╕Ър╕Ъ level-order

```dart
import 'package:algomate/algomate.dart';

void demonstrateBFS() {
  // р╕кр╕гр╣Йр╕▓р╕Зр╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╕кр╕▒р╕Зр╕Др╕б
  final network = Graph<String>(isDirected: false);
  ['р╕кр╕бр╕Кр╕▓р╕в', 'р╕кр╕бр╕лр╕Нр╕┤р╕З', 'р╕кр╕бр╕Ыр╕нр╕З', 'р╕кр╕бр╕лр╕бр╕▓р╕в', 'р╕кр╕бр╕Щр╕╢р╕Б'].forEach(network.addVertex);

  network.addEdge('р╕кр╕бр╕Кр╕▓р╕в', 'р╕кр╕бр╕лр╕Нр╕┤р╕З');
  network.addEdge('р╕кр╕бр╕Кр╕▓р╕в', 'р╕кр╕бр╕Ыр╕нр╕З');
  network.addEdge('р╕кр╕бр╕лр╕Нр╕┤р╕З', 'р╕кр╕бр╕лр╕бр╕▓р╕в');
  network.addEdge('р╕кр╕бр╕Ыр╕нр╕З', 'р╕кр╕бр╕Щр╕╢р╕Б');
  network.addEdge('р╕кр╕бр╕лр╕бр╕▓р╕в', 'р╕кр╕бр╕Щр╕╢р╕Б');

  // р╕гр╕▒р╕Щ BFS р╕Ир╕▓р╕Бр╕кр╕бр╕Кр╕▓р╕в
  final bfsStrategy = BreadthFirstSearchStrategy<String>();
  final result = bfsStrategy.execute(BfsInput(network, 'р╕кр╕бр╕Кр╕▓р╕в'));

  print('ЁЯФН р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М BFS:');
  print('р╕ер╕│р╕Фр╕▒р╕Ър╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕З: ${result.traversalOrder}');
  print('р╕гр╕░р╕вр╕░р╕Чр╕▓р╕Зр╕Цр╕╢р╕Зр╕кр╕бр╕Щр╕╢р╕Б: ${result.getDistance('р╕кр╕бр╕Щр╕╢р╕Б')} р╕Вр╕▒р╣Йр╕Щ');
  print('р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╣Др╕Ыр╕кр╕бр╕Щр╕╢р╕Б: ${result.getPath('р╕кр╕бр╕Щр╕╢р╕Б')}');
  print('р╣Др╕Ыр╣Ар╕вр╕╡р╣Ир╕вр╕бр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф: ${result.visited}');
}
```

**р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М:**

```
ЁЯФН р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М BFS:
р╕ер╕│р╕Фр╕▒р╕Ър╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕З: [р╕кр╕бр╕Кр╕▓р╕в, р╕кр╕бр╕лр╕Нр╕┤р╕З, р╕кр╕бр╕Ыр╕нр╕З, р╕кр╕бр╕лр╕бр╕▓р╕в, р╕кр╕бр╕Щр╕╢р╕Б]
р╕гр╕░р╕вр╕░р╕Чр╕▓р╕Зр╕Цр╕╢р╕Зр╕кр╕бр╕Щр╕╢р╕Б: 2 р╕Вр╕▒р╣Йр╕Щ
р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╣Др╕Ыр╕кр╕бр╕Щр╕╢р╕Б: [р╕кр╕бр╕Кр╕▓р╕в, р╕кр╕бр╕Ыр╕нр╕З, р╕кр╕бр╕Щр╕╢р╕Б]
р╣Др╕Ыр╣Ар╕вр╕╡р╣Ир╕вр╕бр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф: {р╕кр╕бр╕Кр╕▓р╕в, р╕кр╕бр╕лр╕Нр╕┤р╕З, р╕кр╕бр╕Ыр╕нр╕З, р╕кр╕бр╕лр╕бр╕▓р╕в, р╕кр╕бр╕Щр╕╢р╕Б}
```

### Depth-First Search (DFS)

**р╣Ар╕лр╕бр╕▓р╕░р╕кр╕│р╕лр╕гр╕▒р╕Ъ**: р╕Хр╕гр╕зр╕Ир╕Ир╕▒р╕Ъ cycles, topological sorting, р╕Бр╕▓р╕гр╕Щр╕▒р╕Ър╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕З

```dart
void demonstrateDFS() {
  final maze = Graph<String>(isDirected: false);
  ['р╕Ир╕╕р╕Фр╣Ар╕гр╕┤р╣Ир╕б', 'р╕Чр╕▓р╕ЗA', 'р╕Чр╕▓р╕ЗB', 'р╕Чр╕▓р╕ЗC', 'р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в'].forEach(maze.addVertex);

  maze.addEdge('р╕Ир╕╕р╕Фр╣Ар╕гр╕┤р╣Ир╕б', 'р╕Чр╕▓р╕ЗA');
  maze.addEdge('р╕Ир╕╕р╕Фр╣Ар╕гр╕┤р╣Ир╕б', 'р╕Чр╕▓р╕ЗB');
  maze.addEdge('р╕Чр╕▓р╕ЗA', 'р╕Чр╕▓р╕ЗC');
  maze.addEdge('р╕Чр╕▓р╕ЗB', 'р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в');
  maze.addEdge('р╕Чр╕▓р╕ЗC', 'р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в');

  final dfsStrategy = DepthFirstSearchStrategy<String>();
  final result = dfsStrategy.execute(DfsInput(maze, 'р╕Ир╕╕р╕Фр╣Ар╕гр╕┤р╣Ир╕б'));

  print('ЁЯУК р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М DFS:');
  print('р╕ер╕│р╕Фр╕▒р╕Ър╕Бр╕▓р╕гр╕Чр╣Ир╕нр╕З: ${result.traversalOrder}');
  print('р╣Ар╕зр╕ер╕▓р╕Юр╕Ър╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в: ${result.getDiscoveryTime('р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в')}');
  print('р╣Ар╕зр╕ер╕▓р╣Ар╕кр╕гр╣Зр╕Ир╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в: ${result.getFinishTime('р╣Ар╕Ыр╣Йр╕▓р╕лр╕бр╕▓р╕в')}');
}
```

## ЁЯЧ║я╕П р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Ф

### Dijkstra's Algorithm

**р╣Ар╕лр╕бр╕▓р╕░р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕кр╕│р╕лр╕гр╕▒р╕Ъ**: р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Фр╕Ир╕▓р╕Бр╕Ир╕╕р╕Фр╣Ар╕Фр╕╡р╕вр╕з р╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕╡р╕Щр╣Йр╕│р╕лр╕Щр╕▒р╕Бр╕Хр╕┤р╕Фр╕ер╕Ъ

```dart
void demonstrateDijkstra() {
  // р╕кр╕гр╣Йр╕▓р╕Зр╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╕Цр╕Щр╕Щ
  final roads = Graph<String>(isDirected: true, isWeighted: true);

  ['р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю', 'р╣Ар╕Кр╕╡р╕вр╕Зр╣Гр╕лр╕бр╣И', 'р╕ар╕╣р╣Ар╕Бр╣Зр╕Х', 'р╕Юр╕▒р╕Чр╕вр╕▓', 'р╕Вр╕нр╕Щр╣Бр╕Бр╣Ир╕Щ'].forEach(roads.addVertex);

  // р╣Ар╕Юр╕┤р╣Ир╕бр╕Цр╕Щр╕Щр╕Юр╕гр╣Йр╕нр╕бр╕гр╕░р╕вр╕░р╕Чр╕▓р╕З (р╕Бр╕┤р╣Вр╕ер╣Ар╕бр╕Хр╕г)
  roads.addEdge('р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю', 'р╣Ар╕Кр╕╡р╕вр╕Зр╣Гр╕лр╕бр╣И', weight: 700);
  roads.addEdge('р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю', 'р╕ар╕╣р╣Ар╕Бр╣Зр╕Х', weight: 850);
  roads.addEdge('р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю', 'р╕Юр╕▒р╕Чр╕вр╕▓', weight: 150);
  roads.addEdge('р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю', 'р╕Вр╕нр╕Щр╣Бр╕Бр╣Ир╕Щ', weight: 450);
  roads.addEdge('р╣Ар╕Кр╕╡р╕вр╕Зр╣Гр╕лр╕бр╣И', 'р╕Вр╕нр╕Щр╣Бр╕Бр╣Ир╕Щ', weight: 300);
  roads.addEdge('р╕Юр╕▒р╕Чр╕вр╕▓', 'р╕ар╕╣р╣Ар╕Бр╣Зр╕Х', weight: 750);

  final dijkstraStrategy = DijkstraAlgorithmStrategy<String>();
  final result = dijkstraStrategy.execute(DijkstraInput(roads, 'р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю'));

  print('ЁЯОп р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Dijkstra р╕Ир╕▓р╕Бр╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю:');
  for (final city in roads.vertices) {
    if (city != 'р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю') {
      final distance = result.getDistance(city);
      final path = result.getPath(city);
      print('р╣Др╕Ы $city: ${distance?.toStringAsFixed(0)}р╕Бр╕б. р╕Ьр╣Ир╕▓р╕Щ $path');
    }
  }
}
```

**р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М:**

```
ЁЯОп р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Dijkstra р╕Ир╕▓р╕Бр╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю:
р╣Др╕Ы р╣Ар╕Кр╕╡р╕вр╕Зр╣Гр╕лр╕бр╣И: 700р╕Бр╕б. р╕Ьр╣Ир╕▓р╕Щ [р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю, р╣Ар╕Кр╕╡р╕вр╕Зр╣Гр╕лр╕бр╣И]
р╣Др╕Ы р╕ар╕╣р╣Ар╕Бр╣Зр╕Х: 850р╕Бр╕б. р╕Ьр╣Ир╕▓р╕Щ [р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю, р╕ар╕╣р╣Ар╕Бр╣Зр╕Х]
р╣Др╕Ы р╕Юр╕▒р╕Чр╕вр╕▓: 150р╕Бр╕б. р╕Ьр╣Ир╕▓р╕Щ [р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю, р╕Юр╕▒р╕Чр╕вр╕▓]
р╣Др╕Ы р╕Вр╕нр╕Щр╣Бр╕Бр╣Ир╕Щ: 450р╕Бр╕б. р╕Ьр╣Ир╕▓р╕Щ [р╕Бр╕гр╕╕р╕Зр╣Ар╕Чр╕Ю, р╕Вр╕нр╕Щр╣Бр╕Бр╣Ир╕Щ]
```

### Bellman-Ford Algorithm

**р╣Ар╕лр╕бр╕▓р╕░р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕кр╕│р╕лр╕гр╕▒р╕Ъ**: р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Фр╕Ир╕▓р╕Бр╕Ир╕╕р╕Фр╣Ар╕Фр╕╡р╕вр╕з р╕Чр╕╡р╣Ир╕бр╕╡р╕Щр╣Йр╕│р╕лр╕Щр╕▒р╕Бр╕Хр╕┤р╕Фр╕ер╕Ъ, р╕Хр╕гр╕зр╕Ир╕Ир╕▒р╕Ъ cycle

```dart
void demonstrateBellmanFord() {
  // р╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╕Бр╕▓р╕гр╣Ар╕Зр╕┤р╕Щр╕Чр╕╡р╣Ир╕нр╕▓р╕Ир╕бр╕╡р╕Бр╕▓р╕гр╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╕вр╣Йр╕нр╕Щр╕лр╕ер╕▒р╕З
  final finance = Graph<String>(isDirected: true, isWeighted: true);

  ['р╕Ър╕▒р╕Нр╕Кр╕╡A', 'р╕Ър╕▒р╕Нр╕Кр╕╡B', 'р╕Ър╕▒р╕Нр╕Кр╕╡C', 'р╕Ър╕▒р╕Нр╕Кр╕╡D'].forEach(finance.addVertex);

  // р╕Бр╕▓р╕гр╣Вр╕нр╕Щр╕Ыр╕Бр╕Хр╕┤ (р╕Ър╕зр╕Б)
  finance.addEdge('р╕Ър╕▒р╕Нр╕Кр╕╡A', 'р╕Ър╕▒р╕Нр╕Кр╕╡B', weight: 100);
  finance.addEdge('р╕Ър╕▒р╕Нр╕Кр╕╡B', 'р╕Ър╕▒р╕Нр╕Кр╕╡C', weight: 50);

  // р╕Бр╕▓р╕гр╕Др╕╖р╕Щр╣Ар╕Зр╕┤р╕Щр╕лр╕гр╕╖р╕нр╕Бр╕▓р╕гр╣Бр╕Бр╣Йр╣Др╕В (р╕ер╕Ъ)
  finance.addEdge('р╕Ър╕▒р╕Нр╕Кр╕╡C', 'р╕Ър╕▒р╕Нр╕Кр╕╡A', weight: -30);
  finance.addEdge('р╕Ър╕▒р╕Нр╕Кр╕╡A', 'р╕Ър╕▒р╕Нр╕Кр╕╡D', weight: 200);

  final bellmanFordStrategy = BellmanFordAlgorithmStrategy<String>();
  final result = bellmanFordStrategy.execute(BellmanFordInput(finance, 'р╕Ър╕▒р╕Нр╕Кр╕╡A'));

  print('тЪб р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Bellman-Ford:');
  if (result.hasNegativeCycle) {
    print('тЪая╕П  р╕Хр╕гр╕зр╕Ир╕Юр╕Ъ negative cycle! р╕Юр╕Ър╣Вр╕нр╕Бр╕▓р╕кр╣Гр╕Щр╕Бр╕▓р╕гр╣Ар╕Бр╣Зр╕Зр╕Бр╕│р╣Др╕г');
  } else {
    print('тЬЕ р╣Др╕бр╣Ир╕бр╕╡ negative cycles');
    for (final account in finance.vertices) {
      if (account != 'р╕Ър╕▒р╕Нр╕Кр╕╡A') {
        final cost = result.getDistance(account);
        print('р╕Хр╣Йр╕Щр╕Чр╕╕р╕Щр╕кр╕╕р╕Чр╕Шр╕┤р╣Др╕Ы $account: ${cost?.toStringAsFixed(2)} р╕Ър╕▓р╕Ч');
      }
    }
  }
}
```

### Floyd-Warshall Algorithm

**р╣Ар╕лр╕бр╕▓р╕░р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕кр╕│р╕лр╕гр╕▒р╕Ъ**: р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Фр╕гр╕░р╕лр╕зр╣Ир╕▓р╕Зр╕Чр╕╕р╕Бр╕Др╕╣р╣Ир╕Ир╕╕р╕Ф, dense graphs

```dart
void demonstrateFloydWarshall() {
  // р╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╣Ар╕бр╕╖р╕нр╕Зр╣Бр╕Ър╕Ър╕Др╕гр╕Ър╕Цр╣Йр╕зр╕Щ
  final cities = Graph<String>(isDirected: true, isWeighted: true);

  ['A', 'B', 'C', 'D'].forEach(cities.addVertex);

  // р╣Ар╕Юр╕┤р╣Ир╕бр╕Бр╕▓р╕гр╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕нр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф
  cities.addEdge('A', 'B', weight: 5);
  cities.addEdge('A', 'C', weight: 10);
  cities.addEdge('B', 'C', weight: 3);
  cities.addEdge('B', 'D', weight: 20);
  cities.addEdge('C', 'D', weight: 2);

  final floydWarshallStrategy = FloydWarshallAlgorithmStrategy<String>();
  final result = floydWarshallStrategy.execute(FloydWarshallInput(cities));

  print('ЁЯМР р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Floyd-Warshall р╕Чр╕╕р╕Бр╕Др╕╣р╣И:');
  for (final from in cities.vertices) {
    for (final to in cities.vertices) {
      if (from != to) {
        final distance = result.getDistance(from, to);
        print('$from тЖТ $to: ${distance?.toStringAsFixed(0)}');
      }
    }
  }
}
```

## ЁЯМ│ р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Minimum Spanning Tree

### Prim's Algorithm

**р╣Ар╕лр╕бр╕▓р╕░р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕кр╕│р╕лр╕гр╕▒р╕Ъ**: Dense graphs, р╣Ар╕бр╕╖р╣Ир╕нр╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╣Ар╕гр╕┤р╣Ир╕бр╕Ир╕▓р╕Бр╕Ир╕╕р╕Фр╕вр╕нр╕Фр╣Ар╕Йр╕Юр╕▓р╕░

```dart
void demonstratePrim() {
  // р╕Бр╕▓р╕гр╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╕Хр╣Йр╕Щр╕Чр╕╕р╕Щр╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щр╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕в
  final network = Graph<String>(isDirected: false, isWeighted: true);

  ['р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М1', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М2', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М3', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М4', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М5'].forEach(network.addVertex);

  // р╕Хр╣Йр╕Щр╕Чр╕╕р╕Щр╕Бр╕▓р╕гр╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕н (р╕Юр╕▒р╕Щр╕Ър╕▓р╕Ч)
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М1', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М2', weight: 100);
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М1', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М3', weight: 200);
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М2', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М3', weight: 50);
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М2', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М4', weight: 150);
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М3', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М4', weight: 75);
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М3', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М5', weight: 120);
  network.addEdge('р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М4', 'р╣Ар╕Лр╕┤р╕гр╣Мр╕Яр╣Ар╕зр╕нр╕гр╣М5', weight: 80);

  final primStrategy = PrimAlgorithmStrategy<String>();
  final result = primStrategy.execute(MstInput(network));

  print('ЁЯМ┐ р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Prim MST:');
  print('р╕Хр╣Йр╕Щр╕Чр╕╕р╕Щр╕гр╕зр╕б: ${result.totalWeight.toStringAsFixed(0)} р╕Юр╕▒р╕Щр╕Ър╕▓р╕Ч');
  print('р╕Бр╕▓р╕гр╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕нр╕Чр╕╡р╣Ир╕Ир╕│р╣Ар╕Ыр╣Зр╕Щ:');
  for (final edge in result.edges) {
    print('  ${edge.source} тЖФ ${edge.destination} (${edge.weight.toStringAsFixed(0)}K)');
  }
}
```

### Kruskal's Algorithm

**р╣Ар╕лр╕бр╕▓р╕░р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕кр╕│р╕лр╕гр╕▒р╕Ъ**: Sparse graphs, р╣Ар╕бр╕╖р╣Ир╕нр╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕г edges р╕Чр╕╡р╣Ир╕Фр╕╡р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╣Вр╕Фр╕вр╕гр╕зр╕б

```dart
void demonstrateKruskal() {
  // р╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╣Ар╕Фр╕╡р╕вр╕зр╕Бр╕▒р╕Ър╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕З Prim
  final network = Graph<String>(isDirected: false, isWeighted: true);
  // ... (р╕Бр╕▓р╕гр╕Хр╕▒р╣Йр╕Зр╕Др╣Ир╕▓р╣Ар╕Фр╕╡р╕вр╕зр╕Бр╕▒р╕Ър╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕З Prim)

  final kruskalStrategy = KruskalAlgorithmStrategy<String>();
  final result = kruskalStrategy.execute(MstInput(network));

  print('ЁЯФЧ р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Kruskal MST:');
  print('р╕Хр╣Йр╕Щр╕Чр╕╕р╕Щр╕гр╕зр╕б: ${result.totalWeight.toStringAsFixed(0)} р╕Юр╕▒р╕Щр╕Ър╕▓р╕Ч');
  print('Edges р╕Хр╕▓р╕бр╕ер╕│р╕Фр╕▒р╕Ър╕Бр╕▓р╕гр╣Ар╕ер╕╖р╕нр╕Б:');
  for (final edge in result.edges) {
    print('  ${edge.source} тЖФ ${edge.destination} (${edge.weight.toStringAsFixed(0)}K)');
  }
}
```

## ЁЯФм р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕З

### Topological Sort

**р╣Ар╕лр╕бр╕▓р╕░р╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕кр╕│р╕лр╕гр╕▒р╕Ъ**: р╕Бр╕▓р╕гр╕Ир╕▒р╕Фр╕Хр╕▓р╕гр╕▓р╕Зр╕Зр╕▓р╕Щ, р╕Бр╕▓р╕гр╣Бр╕Бр╣Йр╣Др╕В dependency, р╕Бр╕▓р╕гр╕зр╕▓р╕Зр╣Бр╕Ьр╕Щр╕лр╕ер╕▒р╕Бр╕кр╕╣р╕Хр╕г

```dart
void demonstrateTopologicalSort() {
  // р╕зр╕┤р╕Кр╕▓р╣Ар╕гр╕╡р╕вр╕Щр╕Вр╕нр╕Зр╕бр╕лр╕▓р╕зр╕┤р╕Чр╕вр╕▓р╕ер╕▒р╕вр╕Чр╕╡р╣Ир╕бр╕╡ prerequisites
  final courses = Graph<String>(isDirected: true);

  ['р╕Др╕Ур╕┤р╕Х101', 'р╕Др╕Ур╕┤р╕Х201', 'р╕Др╕нр╕б101', 'р╕Др╕нр╕б201', 'р╕Др╕нр╕б301', 'р╕Яр╕┤р╕кр╕┤р╕Бр╕кр╣М101', 'р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е', 'р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б'].forEach(courses.addVertex);

  // Prerequisites (р╕Ир╕▓р╕Б prerequisite р╣Др╕Ыр╕вр╕▒р╕Зр╕зр╕┤р╕Кр╕▓)
  courses.addEdge('р╕Др╕Ур╕┤р╕Х101', 'р╕Др╕Ур╕┤р╕Х201');
  courses.addEdge('р╕Др╕Ур╕┤р╕Х101', 'р╕Яр╕┤р╕кр╕┤р╕Бр╕кр╣М101');
  courses.addEdge('р╕Др╕нр╕б101', 'р╕Др╕нр╕б201');
  courses.addEdge('р╕Др╕нр╕б101', 'р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е');
  courses.addEdge('р╕Др╕нр╕б201', 'р╕Др╕нр╕б301');
  courses.addEdge('р╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е', 'р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б');
  courses.addEdge('р╕Др╕Ур╕┤р╕Х201', 'р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б');

  final topSortStrategy = TopologicalSortStrategy<String>();
  final result = topSortStrategy.execute(TopologicalSortInput(courses));

  print('ЁЯУЛ р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Topological Sort:');
  if (result.isValid) {
    print('тЬЕ р╕ер╕│р╕Фр╕▒р╕Ър╕зр╕┤р╕Кр╕▓р╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З (р╣Др╕бр╣Ир╕бр╕╡ prerequisite cycles):');
    print('ЁЯУЪ ${result.sortedVertices.join(' тЖТ ')}');
  } else {
    print('тЭМ р╕Хр╕гр╕зр╕Ир╕Юр╕Ъ prerequisite cycle! р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕кр╕гр╣Йр╕▓р╕Зр╕ер╕│р╕Фр╕▒р╕Ър╕Чр╕╡р╣Ир╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕Зр╣Др╕Фр╣Й');
  }
}
```

### Strongly Connected Components

#### Kosaraju's Algorithm

```dart
void demonstrateKosaraju() {
  // р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕ер╕┤р╕Зр╕Бр╣Мр╕лр╕Щр╣Йр╕▓р╣Ар╕зр╣Зр╕Ъ
  final web = Graph<String>(isDirected: true);

  ['р╕лр╕Щр╣Йр╕▓р╕лр╕ер╕▒р╕Б', 'р╣Ар╕Бр╕╡р╣Ир╕вр╕зр╕Бр╕▒р╕Ъ', 'р╕кр╕┤р╕Щр╕Др╣Йр╕▓', 'р╕Ър╕ер╣Зр╕нр╕Б', 'р╕Хр╕┤р╕Фр╕Хр╣Ир╕н', 'р╕кр╕Щр╕▒р╕Ър╕кр╕Щр╕╕р╕Щ'].forEach(web.addVertex);

  // р╕ер╕┤р╕Зр╕Бр╣Мр╕гр╕░р╕лр╕зр╣Ир╕▓р╕Зр╕лр╕Щр╣Йр╕▓
  web.addEdge('р╕лр╕Щр╣Йр╕▓р╕лр╕ер╕▒р╕Б', 'р╣Ар╕Бр╕╡р╣Ир╕вр╕зр╕Бр╕▒р╕Ъ');
  web.addEdge('р╕лр╕Щр╣Йр╕▓р╕лр╕ер╕▒р╕Б', 'р╕кр╕┤р╕Щр╕Др╣Йр╕▓');
  web.addEdge('р╣Ар╕Бр╕╡р╣Ир╕вр╕зр╕Бр╕▒р╕Ъ', 'р╕лр╕Щр╣Йр╕▓р╕лр╕ер╕▒р╕Б');
  web.addEdge('р╕кр╕┤р╕Щр╕Др╣Йр╕▓', 'р╕Ър╕ер╣Зр╕нр╕Б');
  web.addEdge('р╕Ър╕ер╣Зр╕нр╕Б', 'р╕кр╕┤р╕Щр╕Др╣Йр╕▓');
  web.addEdge('р╕Хр╕┤р╕Фр╕Хр╣Ир╕н', 'р╕кр╕Щр╕▒р╕Ър╕кр╕Щр╕╕р╕Щ');
  web.addEdge('р╕кр╕Щр╕▒р╕Ър╕кр╕Щр╕╕р╕Щ', 'р╕Хр╕┤р╕Фр╕Хр╣Ир╕н');

  final kosarajuStrategy = KosarajuAlgorithmStrategy<String>();
  final result = kosarajuStrategy.execute(SccInput(web));

  print('ЁЯФН р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Kosaraju SCC:');
  print('р╕Юр╕Ъ ${result.componentCount} р╕Бр╕ер╕╕р╣Ир╕бр╕Чр╕╡р╣Ир╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕нр╣Бр╕Щр╣Ир╕Щр╣Бр╕Яр╣Йр╕Щ:');
  for (int i = 0; i < result.components.length; i++) {
    print('  р╕Бр╕ер╕╕р╣Ир╕б ${i + 1}: {${result.components[i].join(', ')}}');
  }
}
```

#### Tarjan's Algorithm

```dart
void demonstrateTarjan() {
  // р╕Бр╕гр╕▓р╕Яр╣Ар╕Фр╕╡р╕вр╕зр╕Бр╕▒р╕Ър╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕З Kosaraju
  final tarjanStrategy = TarjanAlgorithmStrategy<String>();
  final result = tarjanStrategy.execute(SccInput(web));

  print('тЪб р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣М Tarjan SCC:');
  print('р╕Юр╕Ъ ${result.componentCount} р╕Бр╕ер╕╕р╣Ир╕бр╕Чр╕╡р╣Ир╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕нр╣Бр╕Щр╣Ир╕Щр╣Бр╕Яр╣Йр╕Щ:');
  for (int i = 0; i < result.components.length; i++) {
    print('  р╕Бр╕ер╕╕р╣Ир╕б ${i + 1}: {${result.components[i].join(', ')}}');
  }
}
```

## ЁЯОо р╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕Зр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Ир╕гр╕┤р╕З

### 1. ЁЯЧ║я╕П р╕гр╕░р╕Ър╕Ър╕Щр╕│р╕Чр╕▓р╕З GPS

```dart
class GPSNavigationSystem {
  final DijkstraAlgorithmStrategy<String> _dijkstra = DijkstraAlgorithmStrategy<String>();
  final BreadthFirstSearchStrategy<String> _bfs = BreadthFirstSearchStrategy<String>();

  /// р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕Чр╕╡р╣Ир╕кр╕▒р╣Йр╕Щр╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕гр╕░р╕лр╕зр╣Ир╕▓р╕Зр╕кр╕нр╕Зр╕кр╕Цр╕▓р╕Щр╕Чр╕╡р╣И
  NavigationResult findShortestRoute(Graph<String> roadNetwork, String start, String destination) {
    final result = _dijkstra.execute(DijkstraInput(roadNetwork, start));

    final distance = result.getDistance(destination);
    final path = result.getPath(destination);

    if (distance != null && path.isNotEmpty) {
      return NavigationResult.success(
        route: path,
        totalDistance: distance,
        estimatedTime: distance / 60, // р╕кр╕бр╕бр╕Хр╕┤р╕Др╕зр╕▓р╕бр╣Ар╕гр╣Зр╕зр╣Ар╕Йр╕ер╕╡р╣Ир╕в 60 р╕Бр╕б./р╕Кр╕б.
      );
    } else {
      return NavigationResult.noRouteFound();
    }
  }

  /// р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕Чр╕▓р╕Зр╣Ар╕ер╕╖р╕нр╕Бр╣Вр╕Фр╕вр╣Гр╕Кр╣Й BFS (р╣Ар╕Юр╕╖р╣Ир╕нр╕лр╕ер╕╡р╕Бр╣Ар╕ер╕╡р╣Ир╕вр╕Зр╕Бр╕▓р╕гр╕Ир╕гр╕▓р╕Ир╕г)
  List<List<String>> findAlternativeRoutes(Graph<String> roadNetwork, String start, String destination) {
    // р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Ир╕гр╕┤р╕Зр╕Ир╕░р╣Гр╕Кр╣Й BFS р╕Чр╕╡р╣Ир╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╣Бр╕ер╣Йр╕зр╣Ар╕Юр╕╖р╣Ир╕нр╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕лр╕ер╕▓р╕вр╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕З
    // р╕Щр╕╡р╣Ир╣Ар╕Ыр╣Зр╕Щр╣Ар╕зр╕нр╕гр╣Мр╕Кр╕▒р╕Щр╕Чр╕╡р╣Ир╕Зр╣Ир╕▓р╕в
    final bfsResult = _bfs.execute(BfsInput(roadNetwork, start));
    return [bfsResult.getPath(destination)];
  }
}

class NavigationResult {
  final bool success;
  final List<String> route;
  final double totalDistance;
  final double estimatedTime;

  const NavigationResult({
    required this.success,
    this.route = const [],
    this.totalDistance = 0.0,
    this.estimatedTime = 0.0,
  });

  factory NavigationResult.success({required List<String> route, required double totalDistance, required double estimatedTime}) {
    return NavigationResult(success: true, route: route, totalDistance: totalDistance, estimatedTime: estimatedTime);
  }

  factory NavigationResult.noRouteFound() {
    return const NavigationResult(success: false);
  }
}
```

### 2. ЁЯУ▒ р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╕кр╕▒р╕Зр╕Др╕б

```dart
class SocialNetworkAnalyzer {
  final BreadthFirstSearchStrategy<String> _bfs = BreadthFirstSearchStrategy<String>();
  final TarjanAlgorithmStrategy<String> _tarjan = TarjanAlgorithmStrategy<String>();

  /// р╕лр╕▓р╕гр╕░р╕Фр╕▒р╕Ър╕Бр╕▓р╕гр╣Бр╕вр╕Бр╕гр╕░р╕лр╕зр╣Ир╕▓р╕Зр╕Др╕Щр╕кр╕нр╕Зр╕Др╕Щ
  int findDegreesOfSeparation(Graph<String> socialNetwork, String person1, String person2) {
    final bfsResult = _bfs.execute(BfsInput(socialNetwork, person1));
    return bfsResult.getDistance(person2) ?? -1; // -1 р╕лр╕бр╕▓р╕вр╕Цр╕╢р╕Зр╣Др╕бр╣Ир╣Ар╕Кр╕╖р╣Ир╕нр╕бр╕Хр╣Ир╕нр╕Бр╕▒р╕Щ
  }

  /// р╕лр╕▓р╕Кр╕╕р╕бр╕Кр╕Щр╕Чр╕╡р╣Ир╕бр╕╡р╕нр╕┤р╕Чр╕Шр╕┤р╕Юр╕е (strongly connected components)
  List<Set<String>> findCommunities(Graph<String> socialNetwork) {
    final sccResult = _tarjan.execute(SccInput(socialNetwork));
    return sccResult.components.where((component) => component.length > 1).toList();
  }

  /// р╣Бр╕Щр╕░р╕Щр╕│р╣Ар╕Юр╕╖р╣Ир╕нр╕Щр╕гр╣Ир╕зр╕бр╕Бр╕▒р╕Щ
  Set<String> suggestMutualFriends(Graph<String> socialNetwork, String person) {
    final bfsResult = _bfs.execute(BfsInput(socialNetwork, person));
    final directFriends = socialNetwork.getEdges(person).map((e) => e.destination).toSet();

    final suggestions = <String>{};
    for (final friend in directFriends) {
      final friendsOfFriend = socialNetwork.getEdges(friend).map((e) => e.destination);
      suggestions.addAll(friendsOfFriend.where((f) => f != person && !directFriends.contains(f)));
    }

    return suggestions;
  }
}
```

### 3. ЁЯПв р╕гр╕░р╕Ър╕Ър╕Ир╕▒р╕Фр╕Хр╕▓р╕гр╕▓р╕Зр╣Вр╕Др╕гр╕Зр╕Бр╕▓р╕г

```dart
class ProjectScheduler {
  final TopologicalSortStrategy<String> _topSort = TopologicalSortStrategy<String>();
  final DijkstraAlgorithmStrategy<String> _dijkstra = DijkstraAlgorithmStrategy<String>();

  /// р╕кр╕гр╣Йр╕▓р╕Зр╕Хр╕▓р╕гр╕▓р╕Зр╕Зр╕▓р╕Щр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕бр╣Вр╕Фр╕вр╣Ар╕Др╕▓р╕гр╕Ю dependencies
  ScheduleResult createSchedule(Graph<String> taskDependencies, Map<String, Duration> taskDurations) {
    final topSortResult = _topSort.execute(TopologicalSortInput(taskDependencies));

    if (!topSortResult.isValid) {
      return ScheduleResult.cyclicDependencies();
    }

    final schedule = <String, DateTime>{};
    var currentTime = DateTime.now();

    for (final task in topSortResult.sortedVertices) {
      schedule[task] = currentTime;
      currentTime = currentTime.add(taskDurations[task] ?? Duration.zero);
    }

    return ScheduleResult.success(
      taskOrder: topSortResult.sortedVertices,
      schedule: schedule,
      projectDuration: currentTime.difference(DateTime.now()),
    );
  }

  /// р╕лр╕▓ critical path (р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕Чр╕╡р╣Ир╕вр╕▓р╕зр╕Чр╕╡р╣Ир╕кр╕╕р╕Фр╕Чр╕╡р╣Ир╕Бр╕│р╕лр╕Щр╕Фр╕гр╕░р╕вр╕░р╣Ар╕зр╕ер╕▓р╣Вр╕Др╕гр╕Зр╕Бр╕▓р╕г)
  List<String> findCriticalPath(Graph<String> taskNetwork, Map<String, Duration> taskDurations) {
    // р╣Бр╕Ыр╕ер╕Зр╣Ар╕Ыр╣Зр╕Щ weighted graph р╕Чр╕╡р╣Ир╕Щр╣Йр╕│р╕лр╕Щр╕▒р╕Бр╕Др╕╖р╕нр╕гр╕░р╕вр╕░р╣Ар╕зр╕ер╕▓р╕Зр╕▓р╕Щ
    final weightedNetwork = Graph<String>(isDirected: true, isWeighted: true);

    for (final vertex in taskNetwork.vertices) {
      weightedNetwork.addVertex(vertex);
    }

    for (final vertex in taskNetwork.vertices) {
      for (final edge in taskNetwork.getEdges(vertex)) {
        final duration = taskDurations[edge.destination]?.inHours.toDouble() ?? 0.0;
        weightedNetwork.addEdge(vertex, edge.destination, weight: duration);
      }
    }

    // р╕лр╕▓ longest path (critical path) - р╕Хр╣Йр╕нр╕Зр╣Гр╕Кр╣Й longest path algorithm
    // р╕Хр╕нр╕Щр╕Щр╕╡р╣Йр╣Гр╕Кр╣Й topological order р╣Ар╕Ыр╣Зр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕▓р╕У
    final topSortResult = _topSort.execute(TopologicalSortInput(taskNetwork));
    return topSortResult.sortedVertices;
  }
}

class ScheduleResult {
  final bool success;
  final List<String> taskOrder;
  final Map<String, DateTime> schedule;
  final Duration projectDuration;
  final String? errorMessage;

  const ScheduleResult({
    required this.success,
    this.taskOrder = const [],
    this.schedule = const {},
    this.projectDuration = Duration.zero,
    this.errorMessage,
  });

  factory ScheduleResult.success({
    required List<String> taskOrder,
    required Map<String, DateTime> schedule,
    required Duration projectDuration,
  }) {
    return ScheduleResult(
      success: true,
      taskOrder: taskOrder,
      schedule: schedule,
      projectDuration: projectDuration,
    );
  }

  factory ScheduleResult.cyclicDependencies() {
    return const ScheduleResult(
      success: false,
      errorMessage: 'р╕Хр╕гр╕зр╕Ир╕Юр╕Ъ cyclic dependencies р╣Гр╕Щр╕Бр╕гр╕▓р╕Яр╕Зр╕▓р╕Щ',
    );
  }
}
```

## тЪб р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю

### р╕Ьр╕ер╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю

р╕Ир╕▓р╕Бр╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Юр╕Ир╕гр╕┤р╕Зр╕Бр╕▒р╕Ър╕Вр╕Щр╕▓р╕Фр╕Бр╕гр╕▓р╕Яр╕Хр╣Ир╕▓р╕Зр╣Ж:

| р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б      | р╕Вр╕Щр╕▓р╕Фр╕Бр╕гр╕▓р╕Я | р╕Ир╕╕р╕Фр╕вр╕нр╕Ф | р╣Ар╕кр╣Йр╕Щр╣Ар╕Кр╕╖р╣Ир╕нр╕б | р╣Ар╕зр╕ер╕▓р╕Бр╕▓р╕гр╕Чр╕│р╕Зр╕▓р╕Щ | Throughput |
| --------------- | -------- | ------ | ---------- | ------------ | ---------- |
| **BFS**         | р╣Ар╕ер╣Зр╕Б     | 100    | 200        | 0.15ms       | 667K V/s   |
| **BFS**         | р╕Бр╕ер╕▓р╕З     | 1,000  | 2,000      | 1.2ms        | 833K V/s   |
| **BFS**         | р╣Гр╕лр╕Нр╣И     | 10,000 | 20,000     | 12ms         | 833K V/s   |
| **DFS**         | р╣Ар╕ер╣Зр╕Б     | 100    | 200        | 0.12ms       | 833K V/s   |
| **DFS**         | р╕Бр╕ер╕▓р╕З     | 1,000  | 2,000      | 1.0ms        | 1M V/s     |
| **DFS**         | р╣Гр╕лр╕Нр╣И     | 10,000 | 20,000     | 10ms         | 1M V/s     |
| **Dijkstra**    | р╣Ар╕ер╣Зр╕Б     | 100    | 200        | 0.8ms        | 125K V/s   |
| **Dijkstra**    | р╕Бр╕ер╕▓р╕З     | 1,000  | 2,000      | 8ms          | 125K V/s   |
| **Dijkstra**    | р╣Гр╕лр╕Нр╣И     | 10,000 | 20,000     | 85ms         | 118K V/s   |
| **Prim MST**    | р╣Ар╕ер╣Зр╕Б     | 100    | 200        | 0.6ms        | 167K V/s   |
| **Prim MST**    | р╕Бр╕ер╕▓р╕З     | 1,000  | 2,000      | 6ms          | 167K V/s   |
| **Kruskal MST** | р╣Ар╕ер╣Зр╕Б     | 100    | 200        | 0.9ms        | 111K V/s   |
| **Kruskal MST** | р╕Бр╕ер╕▓р╕З     | 1,000  | 2,000      | 9ms          | 111K V/s   |

### р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕лр╕Щр╣Ир╕зр╕вр╕Др╕зр╕▓р╕бр╕Ир╕│

| р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б     | Space Complexity | р╕лр╕Щр╣Ир╕зр╕вр╕Др╕зр╕▓р╕бр╕Ир╕│р╕кр╕│р╕лр╕гр╕▒р╕Ъ 10K р╕Ир╕╕р╕Фр╕вр╕нр╕Ф |
| -------------- | ---------------- | ---------------------------- |
| BFS/DFS        | O(V)             | ~40KB                        |
| Dijkstra       | O(V)             | ~40KB                        |
| Floyd-Warshall | O(V┬▓)            | ~400MB                       |
| Prim's MST     | O(V)             | ~40KB                        |
| Kruskal's MST  | O(V + E)         | ~80KB                        |

### р╣Ар╕Др╕ер╣Зр╕Фр╕ер╕▒р╕Ър╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю

1. **р╣Ар╕ер╕╖р╕нр╕Бр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕б**:

   - р╣Гр╕Кр╣Й BFS р╕кр╕│р╕лр╕гр╕▒р╕Ъ unweighted shortest paths
   - р╣Гр╕Кр╣Й Dijkstra р╕кр╕│р╕лр╕гр╕▒р╕Ъ weighted shortest paths р╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕бр╕╡р╕Щр╣Йр╕│р╕лр╕Щр╕▒р╕Бр╕Хр╕┤р╕Фр╕ер╕Ъ
   - р╣Гр╕Кр╣Й Bellman-Ford р╣Ар╕Йр╕Юр╕▓р╕░р╣Ар╕бр╕╖р╣Ир╕нр╕бр╕╡р╕Щр╣Йр╕│р╕лр╕Щр╕▒р╕Бр╕Хр╕┤р╕Фр╕ер╕Ър╣Др╕Фр╣Й

2. **р╕Бр╕▓р╕гр╣Бр╕кр╕Фр╕Зр╕Бр╕гр╕▓р╕Я**:

   - AlgoMate р╣Гр╕Кр╣Й adjacency lists (р╣Ар╕лр╕бр╕▓р╕░р╕кр╕│р╕лр╕гр╕▒р╕Ъ sparse graphs)
   - р╕кр╕│р╕лр╕гр╕▒р╕Ъ dense graphs р╕бр╕▓р╕Б (E тЙИ V┬▓), adjacency matrix р╕нр╕▓р╕Ир╣Ар╕гр╣Зр╕зр╕Бр╕зр╣Ир╕▓

3. **р╕Бр╕▓р╕гр╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╕лр╕Щр╣Ир╕зр╕вр╕Др╕зр╕▓р╕бр╕Ир╕│**:
   - р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕гр╕▓р╕Яр╣Гр╕лр╕Нр╣И, р╕Др╕зр╕гр╣Ар╕ер╕╖р╕нр╕Б Dijkstra р╕бр╕▓р╕Бр╕Бр╕зр╣Ир╕▓ Floyd-Warshall
   - р╣Гр╕Кр╣Й streaming algorithms р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕гр╕▓р╕Яр╕Чр╕╡р╣Ир╣Др╕бр╣Ир╕Юр╕нр╕Фр╕╡р╕Бр╕▒р╕Ър╕лр╕Щр╣Ир╕зр╕вр╕Др╕зр╕▓р╕бр╕Ир╕│

## ЁЯзк р╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╣Бр╕ер╕░р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ

### р╕Кр╕╕р╕Фр╕Чр╕Фр╕кр╕нр╕Ър╕Чр╕╡р╣Ир╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕б

AlgoMate р╕бр╕╡р╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╕нр╕вр╣Ир╕▓р╕Зр╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕бр╕кр╕│р╕лр╕гр╕▒р╕Ър╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф:

```dart
void runGraphAlgorithmTests() {
  group('р╕Бр╕▓р╕гр╕Чр╕Фр╕кр╕нр╕Ър╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph', () {
    test('BFS р╕лр╕▓р╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╕кр╕▒р╣Йр╕Щр╕кр╕╕р╕Фр╣Гр╕Щ unweighted graph', () {
      final graph = Graph<int>(isDirected: false);
      [1, 2, 3, 4, 5].forEach(graph.addVertex);

      graph.addEdge(1, 2);
      graph.addEdge(1, 3);
      graph.addEdge(2, 4);
      graph.addEdge(3, 5);
      graph.addEdge(4, 5);

      final bfsStrategy = BreadthFirstSearchStrategy<int>();
      final result = bfsStrategy.execute(BfsInput(graph, 1));

      expect(result.getDistance(5), equals(2));
      expect(result.getPath(5), equals([1, 3, 5]));
    });

    test('Dijkstra р╕Ир╕▒р╕Фр╕Бр╕▓р╕г weighted graphs р╕нр╕вр╣Ир╕▓р╕Зр╕Цр╕╣р╕Бр╕Хр╣Йр╕нр╕З', () {
      final graph = Graph<String>(isDirected: true, isWeighted: true);
      ['A', 'B', 'C', 'D'].forEach(graph.addVertex);

      graph.addEdge('A', 'B', weight: 10);
      graph.addEdge('A', 'C', weight: 3);
      graph.addEdge('B', 'D', weight: 2);
      graph.addEdge('C', 'D', weight: 8);

      final dijkstraStrategy = DijkstraAlgorithmStrategy<String>();
      final result = dijkstraStrategy.execute(DijkstraInput(graph, 'A'));

      expect(result.getDistance('D'), equals(11)); // A -> C -> D = 3 + 8 = 11
    });

    test('Topological sort р╕Хр╕гр╕зр╕Ир╕Ир╕▒р╕Ъ cycles', () {
      final graph = Graph<String>(isDirected: true);
      ['A', 'B', 'C'].forEach(graph.addVertex);

      // р╕кр╕гр╣Йр╕▓р╕З cycle: A -> B -> C -> A
      graph.addEdge('A', 'B');
      graph.addEdge('B', 'C');
      graph.addEdge('C', 'A');

      final topSortStrategy = TopologicalSortStrategy<String>();
      final result = topSortStrategy.execute(TopologicalSortInput(graph));

      expect(result.isValid, isFalse);
    });

    test('р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б MST р╣Гр╕лр╣Йр╕Щр╣Йр╕│р╕лр╕Щр╕▒р╕Бр╕гр╕зр╕бр╣Ар╕Чр╣Ир╕▓р╕Бр╕▒р╕Щ', () {
      final graph = Graph<int>(isDirected: false, isWeighted: true);
      [1, 2, 3, 4].forEach(graph.addVertex);

      graph.addEdge(1, 2, weight: 10);
      graph.addEdge(1, 3, weight: 15);
      graph.addEdge(2, 3, weight: 5);
      graph.addEdge(2, 4, weight: 20);
      graph.addEdge(3, 4, weight: 8);

      final primStrategy = PrimAlgorithmStrategy<int>();
      final kruskalStrategy = KruskalAlgorithmStrategy<int>();

      final primResult = primStrategy.execute(MstInput(graph));
      final kruskalResult = kruskalStrategy.execute(MstInput(graph));

      expect(primResult.totalWeight, equals(kruskalResult.totalWeight));
      expect(primResult.totalWeight, equals(23)); // 5 + 8 + 10 = 23
    });
  });
}
```

### р╕Бр╕гр╕Ур╕╡р╕Вр╣Йр╕нр╕Ър╕Бр╕Юр╕гр╣Ир╕нр╕Зр╣Бр╕ер╕░р╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ

```dart
void validateGraphAlgorithms() {
  // р╕Чр╕Фр╕кр╕нр╕Ър╕Бр╕▒р╕Ър╕Бр╕гр╕▓р╕Яр╕зр╣Ир╕▓р╕З
  final emptyGraph = Graph<String>(isDirected: false);

  // р╕Чр╕Фр╕кр╕нр╕Ър╕Бр╕▒р╕Ър╕Ир╕╕р╕Фр╕вр╕нр╕Фр╣Ар╕Фр╕╡р╕вр╕з
  final singleVertex = Graph<String>(isDirected: false);
  singleVertex.addVertex('A');

  // р╕Чр╕Фр╕кр╕нр╕Ър╕Бр╕▒р╕Ъ components р╕Чр╕╡р╣Ир╣Бр╕вр╕Бр╕Бр╕▒р╕Щ
  final disconnected = Graph<String>(isDirected: false);
  ['A', 'B', 'C', 'D'].forEach(disconnected.addVertex);
  disconnected.addEdge('A', 'B');
  disconnected.addEdge('C', 'D'); // Component р╣Бр╕вр╕Бр╕Хр╣Ир╕▓р╕Зр╕лр╕▓р╕Б

  // р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Фр╕Др╕зр╕гр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Бр╕гр╕Ур╕╡р╣Ар╕лр╕ер╣Ир╕▓р╕Щр╕╡р╣Йр╕нр╕вр╣Ир╕▓р╕Зр╣Ар╕лр╕бр╕▓р╕░р╕кр╕б
  // р╣Бр╕ер╕░р╕кр╣Ир╕Зр╕Др╕╖р╕Щр╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕лр╕гр╕╖р╕нр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕б
}
```

## ЁЯОУ р╣Бр╕Щр╕зр╕Чр╕▓р╕Зр╕Ыр╕Пр╕┤р╕Ър╕▒р╕Хр╕┤р╕Чр╕╡р╣Ир╕Фр╕╡

### 1. **р╕Др╕╣р╣Ир╕бр╕╖р╕нр╕Бр╕▓р╕гр╣Ар╕ер╕╖р╕нр╕Бр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б**

```dart
class GraphAlgorithmSelector {
  static Strategy<BfsInput<T>, BfsResult<T>> selectTraversalAlgorithm<T>(
    GraphCharacteristics characteristics
  ) {
    if (characteristics.needsShortestPath && !characteristics.isWeighted) {
      return BreadthFirstSearchStrategy<T>();
    } else if (characteristics.needsPathEnumeration || characteristics.hasCycles) {
      return DepthFirstSearchStrategy<T>();
    } else {
      return BreadthFirstSearchStrategy<T>(); // Default р╣Гр╕Кр╣Й BFS
    }
  }

  static Strategy selectShortestPathAlgorithm<T>(
    GraphCharacteristics characteristics
  ) {
    if (characteristics.hasNegativeWeights) {
      return BellmanFordAlgorithmStrategy<T>();
    } else if (characteristics.needsAllPairs) {
      return FloydWarshallAlgorithmStrategy<T>();
    } else {
      return DijkstraAlgorithmStrategy<T>();
    }
  }
}

class GraphCharacteristics {
  final bool isWeighted;
  final bool isDirected;
  final bool hasNegativeWeights;
  final bool needsShortestPath;
  final bool needsAllPairs;
  final bool needsPathEnumeration;
  final bool hasCycles;

  const GraphCharacteristics({
    required this.isWeighted,
    required this.isDirected,
    this.hasNegativeWeights = false,
    this.needsShortestPath = false,
    this.needsAllPairs = false,
    this.needsPathEnumeration = false,
    this.hasCycles = false,
  });
}
```

### 2. **р╕Бр╕▓р╕гр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Ф**

```dart
void safeGraphProcessing<T>(Graph<T> graph, T startVertex) {
  // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ъ inputs
  if (!graph.vertices.contains(startVertex)) {
    throw ArgumentError('р╣Др╕бр╣Ир╕Юр╕Ър╕Ир╕╕р╕Фр╕вр╕нр╕Фр╣Ар╕гр╕┤р╣Ир╕бр╕Хр╣Йр╕Щр╣Гр╕Щр╕Бр╕гр╕▓р╕Я');
  }

  // р╣Гр╕Кр╣Й try-catch р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕гр╕▒р╕Щр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б
  try {
    final bfsStrategy = BreadthFirstSearchStrategy<T>();
    final result = bfsStrategy.execute(BfsInput(graph, startVertex));

    // р╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕нр╕вр╣Ир╕▓р╕Зр╕Ыр╕ер╕нр╕Фр╕ар╕▒р╕в
    processResults(result);
  } catch (e) {
    print('р╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕Бр╕гр╕▓р╕Яр╕ер╣Йр╕бр╣Ар╕лр╕ер╕з: $e');
    // р╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╕нр╕вр╣Ир╕▓р╕Зр╣Ар╕лр╕бр╕▓р╕░р╕кр╕б
  }
}

void processResults<T>(BfsResult<T> result) {
  // р╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Ар╕кр╕бр╕нр╕зр╣Ир╕▓р╕Ир╕╕р╕Фр╕вр╕нр╕Фр╕Цр╕╣р╕Бр╣Ар╕вр╕╡р╣Ир╕вр╕бр╕Ир╕гр╕┤р╕Зр╕лр╕гр╕╖р╕нр╣Др╕бр╣И
  for (final vertex in graph.vertices) {
    final distance = result.getDistance(vertex);
    if (distance != null) {
      print('р╕Ир╕╕р╕Фр╕вр╕нр╕Ф $vertex р╕кр╕▓р╕бр╕▓р╕гр╕Цр╣Ар╕Вр╣Йр╕▓р╕Цр╕╢р╕Зр╣Др╕Фр╣Йр╕Чр╕╡р╣Ир╕гр╕░р╕вр╕░р╕Чр╕▓р╕З $distance');
    } else {
      print('р╕Ир╕╕р╕Фр╕вр╕нр╕Ф $vertex р╣Др╕бр╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╣Ар╕Вр╣Йр╕▓р╕Цр╕╢р╕Зр╣Др╕Фр╣Й');
    }
  }
}
```

### 3. **р╕Бр╕▓р╕гр╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю**

```dart
class OptimizedGraphProcessor<T> {
  // р╣Бр╕Др╕К strategies р╕Чр╕╡р╣Ир╣Гр╕Кр╣Йр╕Ър╣Ир╕нр╕в
  late final BreadthFirstSearchStrategy<T> _bfsStrategy;
  late final DijkstraAlgorithmStrategy<T> _dijkstraStrategy;

  OptimizedGraphProcessor() {
    _bfsStrategy = BreadthFirstSearchStrategy<T>();
    _dijkstraStrategy = DijkstraAlgorithmStrategy<T>();
  }

  // р╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕ер╕лр╕ер╕▓р╕в queries р╕нр╕вр╣Ир╕▓р╕Зр╕бр╕╡р╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Ю
  Map<T, BfsResult<T>> batchBFS(Graph<T> graph, List<T> startVertices) {
    final results = <T, BfsResult<T>>{};

    for (final start in startVertices) {
      if (graph.vertices.contains(start)) {
        results[start] = _bfsStrategy.execute(BfsInput(graph, start));
      }
    }

    return results;
  }

  // р╕Др╕│р╕Щр╕зр╕Ур╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Чр╕╡р╣Ир╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╕Ър╣Ир╕нр╕вр╣Др╕зр╣Йр╕ер╣Ир╕зр╕Зр╕лр╕Щр╣Йр╕▓
  void precomputeDistances(Graph<T> graph, T centralVertex) {
    final result = _dijkstraStrategy.execute(DijkstraInput(graph, centralVertex));
    // р╣Ар╕Бр╣Зр╕Ър╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╣Др╕зр╣Йр╣Гр╕Кр╣Йр╣Гр╕Щр╕ар╕▓р╕вр╕лр╕ер╕▒р╕З
    _distanceCache[centralVertex] = result;
  }

  final Map<T, DijkstraResult<T>> _distanceCache = {};
}
```

---

## ЁЯЪА р╕Ър╕Чр╕кр╕гр╕╕р╕Ы

р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╕Вр╕нр╕З AlgoMate р╕бр╕нр╕Ъ **р╣Вр╕Лр╕ер╕╣р╕Кр╕▒р╕Щр╕Чр╕╡р╣Ир╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕бр╣Бр╕ер╕░р╕Юр╕гр╣Йр╕нр╕бр╣Гр╕Кр╣Йр╣Гр╕Щ production** р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Др╕зр╕▓р╕бр╕Хр╣Йр╕нр╕Зр╕Бр╕▓р╕гр╣Гр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕е Graph р╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Фр╕Вр╕нр╕Зр╕Др╕╕р╕У р╣Др╕бр╣Ир╕зр╣Ир╕▓р╕Др╕╕р╕Ур╕Ир╕░р╕Бр╕│р╕ер╕▒р╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕гр╕░р╕Ър╕Ър╕Щр╕│р╕Чр╕▓р╕З GPS, р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕вр╕кр╕▒р╕Зр╕Др╕б, р╕лр╕гр╕╖р╕нр╕Ыр╕гр╕▒р╕Ър╕Ыр╕гр╕╕р╕Зр╣Вр╕Др╕гр╕Зр╕кр╕гр╣Йр╕▓р╕Зр╕Юр╕╖р╣Йр╕Щр╕Рр╕▓р╕Щр╣Ар╕Др╕гр╕╖р╕нр╕Вр╣Ир╕▓р╕в AlgoMate р╕бр╕╡р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕бр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕бр╕Юр╕гр╣Йр╕нр╕бр╕Ыр╕гр╕░р╕кр╕┤р╕Чр╕Шр╕┤р╕ар╕▓р╕Юр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕б

### р╕Ыр╕гр╕░р╣Ар╕Фр╣Зр╕Щр╕кр╕│р╕Др╕▒р╕Н:

- тЬЕ **р╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б 10+** р╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕бр╕Бр╕гр╕Ур╕╡р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щ Graph р╕лр╕ер╕▒р╕Бр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф
- тЬЕ **Time complexities р╕Чр╕╡р╣Ир╕кр╕нр╕Фр╕Др╕ер╣Йр╕нр╕З O(V + E) р╕Цр╕╢р╕З O(V┬│)** р╕Бр╕▒р╕Ър╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕б
- тЬЕ **р╕Бр╕▓р╕гр╕нр╕нр╕Бр╣Бр╕Ър╕Ъ Generic** р╣Гр╕Кр╣Йр╣Др╕Фр╣Йр╕Бр╕▒р╕Ър╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Ир╕╕р╕Фр╕вр╕нр╕Фр╣Гр╕Фр╕Бр╣Зр╣Др╕Фр╣Й
- тЬЕ **р╕зр╕▒р╕Хр╕Цр╕╕р╕Ьр╕ер╕ер╕▒р╕Юр╕Шр╣Мр╕Чр╕╡р╣Ир╕лр╕ер╕▓р╕Бр╕лр╕ер╕▓р╕в** р╕Юр╕гр╣Йр╕нр╕бр╕Вр╣Йр╕нр╕бр╕╣р╕ер╣Ар╕кр╣Йр╕Щр╕Чр╕▓р╕Зр╣Бр╕ер╕░р╕гр╕░р╕вр╕░р╕Чр╕▓р╕Зр╕Чр╕╡р╣Ир╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕б
- тЬЕ **р╕Чр╕Фр╕кр╕нр╕Ър╣Гр╕Щ Production** р╕Юр╕гр╣Йр╕нр╕бр╕Бр╕▓р╕гр╕Хр╕гр╕зр╕Ир╕кр╕нр╕Ър╣Бр╕ер╕░р╕Бр╕▓р╕гр╕Ир╕▒р╕Фр╕Бр╕▓р╕гр╕Вр╣Йр╕нр╕Ьр╕┤р╕Фр╕Юр╕ер╕▓р╕Фр╕нр╕вр╣Ир╕▓р╕Зр╕Др╕гр╕нр╕Ър╕Др╕ер╕╕р╕б
- тЬЕ **р╕Бр╕▓р╕гр╕гр╕зр╕бр╣Ар╕Вр╣Йр╕▓р╕Зр╣Ир╕▓р╕в** р╕Бр╕▒р╕Ъ Strategy pattern р╕Вр╕нр╕З AlgoMate

р╣Ар╕гр╕┤р╣Ир╕бр╣Гр╕Кр╣Йр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б Graph р╕Вр╕нр╕З AlgoMate р╕зр╕▒р╕Щр╕Щр╕╡р╣Йр╣Бр╕ер╕░р╣Ар╕Ыр╕ер╕╡р╣Ир╕вр╕Щр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕е Graph р╕Вр╕нр╕Зр╕Др╕╕р╕Ур╕Ир╕▓р╕Бр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╣Бр╕Ър╕Ър╕Бр╕│р╕лр╕Щр╕Фр╣Ар╕нр╕Зр╕Чр╕╡р╣Ир╕Лр╕▒р╕Ър╕Лр╣Йр╕нр╕Щр╣Др╕Ыр╕кр╕╣р╣Ир╕Бр╕▓р╕гр╣Ар╕гр╕╡р╕вр╕Бр╣Гр╕Кр╣Йр╕Яр╕▒р╕Зр╕Бр╣Мр╕Кр╕▒р╕Щр╕Чр╕╡р╣Ир╕Зр╣Ир╕▓р╕вр╣Бр╕ер╕░р╕Чр╕гр╕Зр╕Юр╕ер╕▒р╕З!

ЁЯУЦ **р╕Др╕╣р╣Ир╕бр╕╖р╕нр╕Чр╕╡р╣Ир╣Ар╕Бр╕╡р╣Ир╕вр╕зр╕Вр╣Йр╕нр╕З:**

- [р╕Др╕╣р╣Ир╕бр╕╖р╕н Custom Objects](CUSTOM_OBJECTS_GUIDE.md) - р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕нр╕▒р╕ер╕Бр╕нр╕гр╕┤р╕Чр╕╢р╕б graph р╕Бр╕▒р╕Ър╕Ыр╕гр╕░р╣Ар╕ар╕Чр╕Ир╕╕р╕Фр╕вр╕нр╕Фр╕Чр╕╡р╣Ир╕Бр╕│р╕лр╕Щр╕Фр╣Ар╕нр╕З
- [README р╕лр╕ер╕▒р╕Б](README.md) - р╣Ар╕нр╕Бр╕кр╕▓р╕г AlgoMate р╕Йр╕Ър╕▒р╕Ър╕кр╕бр╕Ър╕╣р╕гр╕Ур╣М
- [р╣Вр╕Др╣Йр╕Фр╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕З](example/graph_algorithms_example.dart) - р╕Бр╕▓р╕гр╕кр╕▓р╕Шр╕┤р╕Хр╕Чр╕╡р╣Ир╕кр╕▓р╕бр╕▓р╕гр╕Цр╕гр╕▒р╕Щр╣Др╕Фр╣Й

---

_р╕Др╕╣р╣Ир╕бр╕╖р╕н AlgoMate Graph Algorithms - р╕Чр╕│р╣Гр╕лр╣Йр╕Бр╕▓р╕гр╕Ыр╕гр╕░р╕бр╕зр╕ер╕Ьр╕е Graph р╕Вр╕▒р╣Йр╕Щр╕кр╕╣р╕Зр╣Ар╕Вр╣Йр╕▓р╕Цр╕╢р╕Зр╣Др╕Фр╣Йр╕кр╕│р╕лр╕гр╕▒р╕Ър╕Чр╕╕р╕Бр╕Др╕Щ_ ЁЯМР
