# üåê ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠ Graph Algorithms ‡∏Ç‡∏≠‡∏á AlgoMate ‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå

**‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡πÉ‡∏ô AlgoMate - ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÑ‡∏õ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á**

## üìñ ‡∏™‡∏≤‡∏£‡∏ö‡∏±‡∏ç

- [üéØ ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°](#-‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°)
- [üèóÔ∏è ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Graph](#Ô∏è-‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•-graph)
- [üö∂ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü](#-‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü)
- [üó∫Ô∏è ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î](#Ô∏è-‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î)
- [üå≥ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Minimum Spanning Tree](#-‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°-minimum-spanning-tree)
- [üî¨ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á](#-‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°-graph-‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á)
- [üéÆ ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á](#-‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á)
- [‚ö° ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û](#-‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û)
- [üß™ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö](#-‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö)

## üéØ ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°

AlgoMate ‡∏°‡∏µ‡∏ä‡∏∏‡∏î‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô **‡∏Å‡∏ß‡πà‡∏≤ 10+ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°** ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Graph ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:

### ‚úÖ **‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó**

| ‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà                  | ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°                               | Time Complexity            | ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô                               |
| ------------------------- | ---------------------------------------- | -------------------------- | --------------------------------------- |
| **‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü**           | BFS, DFS                                 | O(V + E)                   | ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á, ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠          |
| **‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î**        | Dijkstra, Bellman-Ford, Floyd-Warshall   | O((V+E)logV), O(VE), O(V¬≥) | ‡∏£‡∏∞‡∏ö‡∏ö GPS, ‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á                  |
| **Minimum Spanning Tree** | Prim's, Kruskal's                        | O((V+E)logV), O(ElogE)     | ‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢, ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°         |
| **‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á**   | Topological Sort, SCC (Kosaraju, Tarjan) | O(V + E)                   | ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏≤‡∏ô, ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå dependency |

### üé™ **‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏´‡∏•‡∏±‡∏Å**

- **üß¨ ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Generic**: ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏î‡∏Å‡πá‡πÑ‡∏î‡πâ `T`
- **üèóÔ∏è Strategy Pattern**: ‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏õ‡∏±‡∏ï‡∏¢‡∏Å‡∏£‡∏£‡∏° AlgoMate
- **‚ö° ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á**: ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏î‡πâ‡∏ß‡∏¢ complexity ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà O(V + E) ‡∏ñ‡∏∂‡∏á O(V¬≥)
- **üîß ‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡πà‡∏≤‡∏¢**: ‡∏ó‡∏î‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Graph ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ
- **üìä ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢**: ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á, ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á, ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏°‡∏ï‡∏≤

## üèóÔ∏è ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Graph

### ‡∏Ñ‡∏•‡∏≤‡∏™ Graph<T>

‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏£‡∏≤‡∏ü‡∏´‡∏•‡∏±‡∏Å‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ adjacency lists:

```dart
// ‡∏™‡∏£‡πâ‡∏≤‡∏á Graph ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏ï‡πà‡∏≤‡∏á‡πÜ
final undirectedGraph = Graph<String>(isDirected: false);
final directedWeightedGraph = Graph<String>(isDirected: true, isWeighted: true);

// ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î (vertices) ‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° (edges)
graph.addVertex('A');
graph.addVertex('B');
graph.addEdge('A', 'B', weight: 10.0); // weight ‡πÄ‡∏õ‡πá‡∏ô optional ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö unweighted graphs
```

### ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô

#### Edge<T> ‡πÅ‡∏•‡∏∞ GraphEdge<T>

```dart
class Edge<T> {
  final T destination;
  final double weight;
  const Edge(this.destination, [this.weight = 1.0]);
}

class GraphEdge<T> {
  final T source;
  final T destination;
  final double weight;
  const GraphEdge(this.source, this.destination, [this.weight = 1.0]);
}
```

#### UnionFind<T> (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö MST algorithms)

```dart
class UnionFind<T> {
  final Map<T, T> _parent = {};
  final Map<T, int> _rank = {};

  T find(T element) { /* ... */ }
  void union(T a, T b) { /* ... */ }
  bool connected(T a, T b) => find(a) == find(b);
}
```

## üö∂ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á‡∏Å‡∏£‡∏≤‡∏ü

### Breadth-First Search (BFS)

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÉ‡∏ô unweighted graphs, ‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á‡πÅ‡∏ö‡∏ö level-order

```dart
import 'package:algomate/algomate.dart';

void demonstrateBFS() {
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏™‡∏±‡∏á‡∏Ñ‡∏°
  final network = Graph<String>(isDirected: false);
  ['‡∏™‡∏°‡∏ä‡∏≤‡∏¢', '‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á', '‡∏™‡∏°‡∏õ‡∏≠‡∏á', '‡∏™‡∏°‡∏´‡∏°‡∏≤‡∏¢', '‡∏™‡∏°‡∏ô‡∏∂‡∏Å'].forEach(network.addVertex);

  network.addEdge('‡∏™‡∏°‡∏ä‡∏≤‡∏¢', '‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á');
  network.addEdge('‡∏™‡∏°‡∏ä‡∏≤‡∏¢', '‡∏™‡∏°‡∏õ‡∏≠‡∏á');
  network.addEdge('‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á', '‡∏™‡∏°‡∏´‡∏°‡∏≤‡∏¢');
  network.addEdge('‡∏™‡∏°‡∏õ‡∏≠‡∏á', '‡∏™‡∏°‡∏ô‡∏∂‡∏Å');
  network.addEdge('‡∏™‡∏°‡∏´‡∏°‡∏≤‡∏¢', '‡∏™‡∏°‡∏ô‡∏∂‡∏Å');

  // ‡∏£‡∏±‡∏ô BFS ‡∏à‡∏≤‡∏Å‡∏™‡∏°‡∏ä‡∏≤‡∏¢
  final bfsStrategy = BreadthFirstSearchStrategy<String>();
  final result = bfsStrategy.execute(BfsInput(network, '‡∏™‡∏°‡∏ä‡∏≤‡∏¢'));

  print('üîç ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå BFS:');
  print('‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á: ${result.traversalOrder}');
  print('‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ñ‡∏∂‡∏á‡∏™‡∏°‡∏ô‡∏∂‡∏Å: ${result.getDistance('‡∏™‡∏°‡∏ô‡∏∂‡∏Å')} ‡∏Ç‡∏±‡πâ‡∏ô');
  print('‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÑ‡∏õ‡∏™‡∏°‡∏ô‡∏∂‡∏Å: ${result.getPath('‡∏™‡∏°‡∏ô‡∏∂‡∏Å')}');
  print('‡πÑ‡∏õ‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: ${result.visited}');
}
```

**‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:**

```
üîç ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå BFS:
‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á: [‡∏™‡∏°‡∏ä‡∏≤‡∏¢, ‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á, ‡∏™‡∏°‡∏õ‡∏≠‡∏á, ‡∏™‡∏°‡∏´‡∏°‡∏≤‡∏¢, ‡∏™‡∏°‡∏ô‡∏∂‡∏Å]
‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ñ‡∏∂‡∏á‡∏™‡∏°‡∏ô‡∏∂‡∏Å: 2 ‡∏Ç‡∏±‡πâ‡∏ô
‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÑ‡∏õ‡∏™‡∏°‡∏ô‡∏∂‡∏Å: [‡∏™‡∏°‡∏ä‡∏≤‡∏¢, ‡∏™‡∏°‡∏õ‡∏≠‡∏á, ‡∏™‡∏°‡∏ô‡∏∂‡∏Å]
‡πÑ‡∏õ‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: {‡∏™‡∏°‡∏ä‡∏≤‡∏¢, ‡∏™‡∏°‡∏´‡∏ç‡∏¥‡∏á, ‡∏™‡∏°‡∏õ‡∏≠‡∏á, ‡∏™‡∏°‡∏´‡∏°‡∏≤‡∏¢, ‡∏™‡∏°‡∏ô‡∏∂‡∏Å}
```

### Depth-First Search (DFS)

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö cycles, topological sorting, ‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á

```dart
void demonstrateDFS() {
  final maze = Graph<String>(isDirected: false);
  ['‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°', '‡∏ó‡∏≤‡∏áA', '‡∏ó‡∏≤‡∏áB', '‡∏ó‡∏≤‡∏áC', '‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢'].forEach(maze.addVertex);

  maze.addEdge('‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°', '‡∏ó‡∏≤‡∏áA');
  maze.addEdge('‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°', '‡∏ó‡∏≤‡∏áB');
  maze.addEdge('‡∏ó‡∏≤‡∏áA', '‡∏ó‡∏≤‡∏áC');
  maze.addEdge('‡∏ó‡∏≤‡∏áB', '‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢');
  maze.addEdge('‡∏ó‡∏≤‡∏áC', '‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢');

  final dfsStrategy = DepthFirstSearchStrategy<String>();
  final result = dfsStrategy.execute(DfsInput(maze, '‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°'));

  print('üìä ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå DFS:');
  print('‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡πà‡∏≠‡∏á: ${result.traversalOrder}');
  print('‡πÄ‡∏ß‡∏•‡∏≤‡∏û‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ${result.getDiscoveryTime('‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢')}');
  print('‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ${result.getFinishTime('‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢')}');
}
```

## üó∫Ô∏è ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î

### Dijkstra's Algorithm

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡∏¥‡∏î‡∏•‡∏ö

```dart
void demonstrateDijkstra() {
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏ñ‡∏ô‡∏ô
  final roads = Graph<String>(isDirected: true, isWeighted: true);

  ['‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û', '‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà', '‡∏†‡∏π‡πÄ‡∏Å‡πá‡∏ï', '‡∏û‡∏±‡∏ó‡∏¢‡∏≤', '‡∏Ç‡∏≠‡∏ô‡πÅ‡∏Å‡πà‡∏ô'].forEach(roads.addVertex);

  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ñ‡∏ô‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á (‡∏Å‡∏¥‡πÇ‡∏•‡πÄ‡∏°‡∏ï‡∏£)
  roads.addEdge('‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û', '‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà', weight: 700);
  roads.addEdge('‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û', '‡∏†‡∏π‡πÄ‡∏Å‡πá‡∏ï', weight: 850);
  roads.addEdge('‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û', '‡∏û‡∏±‡∏ó‡∏¢‡∏≤', weight: 150);
  roads.addEdge('‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û', '‡∏Ç‡∏≠‡∏ô‡πÅ‡∏Å‡πà‡∏ô', weight: 450);
  roads.addEdge('‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà', '‡∏Ç‡∏≠‡∏ô‡πÅ‡∏Å‡πà‡∏ô', weight: 300);
  roads.addEdge('‡∏û‡∏±‡∏ó‡∏¢‡∏≤', '‡∏†‡∏π‡πÄ‡∏Å‡πá‡∏ï', weight: 750);

  final dijkstraStrategy = DijkstraAlgorithmStrategy<String>();
  final result = dijkstraStrategy.execute(DijkstraInput(roads, '‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û'));

  print('üéØ ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Dijkstra ‡∏à‡∏≤‡∏Å‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û:');
  for (final city in roads.vertices) {
    if (city != '‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û') {
      final distance = result.getDistance(city);
      final path = result.getPath(city);
      print('‡πÑ‡∏õ $city: ${distance?.toStringAsFixed(0)}‡∏Å‡∏°. ‡∏ú‡πà‡∏≤‡∏ô $path');
    }
  }
}
```

**‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå:**

```
üéØ ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Dijkstra ‡∏à‡∏≤‡∏Å‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û:
‡πÑ‡∏õ ‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà: 700‡∏Å‡∏°. ‡∏ú‡πà‡∏≤‡∏ô [‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û, ‡πÄ‡∏ä‡∏µ‡∏¢‡∏á‡πÉ‡∏´‡∏°‡πà]
‡πÑ‡∏õ ‡∏†‡∏π‡πÄ‡∏Å‡πá‡∏ï: 850‡∏Å‡∏°. ‡∏ú‡πà‡∏≤‡∏ô [‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û, ‡∏†‡∏π‡πÄ‡∏Å‡πá‡∏ï]
‡πÑ‡∏õ ‡∏û‡∏±‡∏ó‡∏¢‡∏≤: 150‡∏Å‡∏°. ‡∏ú‡πà‡∏≤‡∏ô [‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û, ‡∏û‡∏±‡∏ó‡∏¢‡∏≤]
‡πÑ‡∏õ ‡∏Ç‡∏≠‡∏ô‡πÅ‡∏Å‡πà‡∏ô: 450‡∏Å‡∏°. ‡∏ú‡πà‡∏≤‡∏ô [‡∏Å‡∏£‡∏∏‡∏á‡πÄ‡∏ó‡∏û, ‡∏Ç‡∏≠‡∏ô‡πÅ‡∏Å‡πà‡∏ô]
```

### Bellman-Ford Algorithm

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡∏¥‡∏î‡∏•‡∏ö, ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö cycle

```dart
void demonstrateBellmanFord() {
  // ‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á
  final finance = Graph<String>(isDirected: true, isWeighted: true);

  ['‡∏ö‡∏±‡∏ç‡∏ä‡∏µA', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µB', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µC', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µD'].forEach(finance.addVertex);

  // ‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥ (‡∏ö‡∏ß‡∏Å)
  finance.addEdge('‡∏ö‡∏±‡∏ç‡∏ä‡∏µA', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µB', weight: 100);
  finance.addEdge('‡∏ö‡∏±‡∏ç‡∏ä‡∏µB', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µC', weight: 50);

  // ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏∑‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç (‡∏•‡∏ö)
  finance.addEdge('‡∏ö‡∏±‡∏ç‡∏ä‡∏µC', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µA', weight: -30);
  finance.addEdge('‡∏ö‡∏±‡∏ç‡∏ä‡∏µA', '‡∏ö‡∏±‡∏ç‡∏ä‡∏µD', weight: 200);

  final bellmanFordStrategy = BellmanFordAlgorithmStrategy<String>();
  final result = bellmanFordStrategy.execute(BellmanFordInput(finance, '‡∏ö‡∏±‡∏ç‡∏ä‡∏µA'));

  print('‚ö° ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Bellman-Ford:');
  if (result.hasNegativeCycle) {
    print('‚ö†Ô∏è  ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö negative cycle! ‡∏û‡∏ö‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πá‡∏á‡∏Å‡∏≥‡πÑ‡∏£');
  } else {
    print('‚úÖ ‡πÑ‡∏°‡πà‡∏°‡∏µ negative cycles');
    for (final account in finance.vertices) {
      if (account != '‡∏ö‡∏±‡∏ç‡∏ä‡∏µA') {
        final cost = result.getDistance(account);
        print('‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏™‡∏∏‡∏ó‡∏ò‡∏¥‡πÑ‡∏õ $account: ${cost?.toStringAsFixed(2)} ‡∏ö‡∏≤‡∏ó');
      }
    }
  }
}
```

### Floyd-Warshall Algorithm

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà‡∏à‡∏∏‡∏î, dense graphs

```dart
void demonstrateFloydWarshall() {
  // ‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡πÄ‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô
  final cities = Graph<String>(isDirected: true, isWeighted: true);

  ['A', 'B', 'C', 'D'].forEach(cities.addVertex);

  // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  cities.addEdge('A', 'B', weight: 5);
  cities.addEdge('A', 'C', weight: 10);
  cities.addEdge('B', 'C', weight: 3);
  cities.addEdge('B', 'D', weight: 20);
  cities.addEdge('C', 'D', weight: 2);

  final floydWarshallStrategy = FloydWarshallAlgorithmStrategy<String>();
  final result = floydWarshallStrategy.execute(FloydWarshallInput(cities));

  print('üåê ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Floyd-Warshall ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà:');
  for (final from in cities.vertices) {
    for (final to in cities.vertices) {
      if (from != to) {
        final distance = result.getDistance(from, to);
        print('$from ‚Üí $to: ${distance?.toStringAsFixed(0)}');
      }
    }
  }
}
```

## üå≥ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Minimum Spanning Tree

### Prim's Algorithm

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: Dense graphs, ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞

```dart
void demonstratePrim() {
  // ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢
  final network = Graph<String>(isDirected: false, isWeighted: true);

  ['‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå1', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå2', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå3', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå4', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå5'].forEach(network.addVertex);

  // ‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ (‡∏û‡∏±‡∏ô‡∏ö‡∏≤‡∏ó)
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå1', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå2', weight: 100);
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå1', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå3', weight: 200);
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå2', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå3', weight: 50);
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå2', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå4', weight: 150);
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå3', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå4', weight: 75);
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå3', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå5', weight: 120);
  network.addEdge('‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå4', '‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå5', weight: 80);

  final primStrategy = PrimAlgorithmStrategy<String>();
  final result = primStrategy.execute(MstInput(network));

  print('üåø ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Prim MST:');
  print('‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏£‡∏ß‡∏°: ${result.totalWeight.toStringAsFixed(0)} ‡∏û‡∏±‡∏ô‡∏ö‡∏≤‡∏ó');
  print('‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô:');
  for (final edge in result.edges) {
    print('  ${edge.source} ‚Üî ${edge.destination} (${edge.weight.toStringAsFixed(0)}K)');
  }
}
```

### Kruskal's Algorithm

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: Sparse graphs, ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ edges ‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÇ‡∏î‡∏¢‡∏£‡∏ß‡∏°

```dart
void demonstrateKruskal() {
  // ‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Prim
  final network = Graph<String>(isDirected: false, isWeighted: true);
  // ... (‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Prim)

  final kruskalStrategy = KruskalAlgorithmStrategy<String>();
  final result = kruskalStrategy.execute(MstInput(network));

  print('üîó ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Kruskal MST:');
  print('‡∏ï‡πâ‡∏ô‡∏ó‡∏∏‡∏ô‡∏£‡∏ß‡∏°: ${result.totalWeight.toStringAsFixed(0)} ‡∏û‡∏±‡∏ô‡∏ö‡∏≤‡∏ó');
  print('Edges ‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å:');
  for (final edge in result.edges) {
    print('  ${edge.source} ‚Üî ${edge.destination} (${edge.weight.toStringAsFixed(0)}K)');
  }
}
```

## üî¨ ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á

### Topological Sort

**‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö**: ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏≤‡∏ô, ‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç dependency, ‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏™‡∏π‡∏ï‡∏£

```dart
void demonstrateTopologicalSort() {
  // ‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏Ç‡∏≠‡∏á‡∏°‡∏´‡∏≤‡∏ß‡∏¥‡∏ó‡∏¢‡∏≤‡∏•‡∏±‡∏¢‡∏ó‡∏µ‡πà‡∏°‡∏µ prerequisites
  final courses = Graph<String>(isDirected: true);

  ['‡∏Ñ‡∏ì‡∏¥‡∏ï101', '‡∏Ñ‡∏ì‡∏¥‡∏ï201', '‡∏Ñ‡∏≠‡∏°101', '‡∏Ñ‡∏≠‡∏°201', '‡∏Ñ‡∏≠‡∏°301', '‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå101', '‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•', '‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°'].forEach(courses.addVertex);

  // Prerequisites (‡∏à‡∏≤‡∏Å prerequisite ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ß‡∏¥‡∏ä‡∏≤)
  courses.addEdge('‡∏Ñ‡∏ì‡∏¥‡∏ï101', '‡∏Ñ‡∏ì‡∏¥‡∏ï201');
  courses.addEdge('‡∏Ñ‡∏ì‡∏¥‡∏ï101', '‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå101');
  courses.addEdge('‡∏Ñ‡∏≠‡∏°101', '‡∏Ñ‡∏≠‡∏°201');
  courses.addEdge('‡∏Ñ‡∏≠‡∏°101', '‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
  courses.addEdge('‡∏Ñ‡∏≠‡∏°201', '‡∏Ñ‡∏≠‡∏°301');
  courses.addEdge('‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•', '‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°');
  courses.addEdge('‡∏Ñ‡∏ì‡∏¥‡∏ï201', '‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°');

  final topSortStrategy = TopologicalSortStrategy<String>();
  final result = topSortStrategy.execute(TopologicalSortInput(courses));

  print('üìã ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Topological Sort:');
  if (result.isValid) {
    print('‚úÖ ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ß‡∏¥‡∏ä‡∏≤‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏°‡∏µ prerequisite cycles):');
    print('üìö ${result.sortedVertices.join(' ‚Üí ')}');
  } else {
    print('‚ùå ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö prerequisite cycle! ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ');
  }
}
```

### Strongly Connected Components

#### Kosaraju's Algorithm

```dart
void demonstrateKosaraju() {
  // ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
  final web = Graph<String>(isDirected: true);

  ['‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å', '‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö', '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', '‡∏ö‡∏•‡πá‡∏≠‡∏Å', '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠', '‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô'].forEach(web.addVertex);

  // ‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤
  web.addEdge('‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å', '‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö');
  web.addEdge('‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å', '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤');
  web.addEdge('‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö', '‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å');
  web.addEdge('‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤', '‡∏ö‡∏•‡πá‡∏≠‡∏Å');
  web.addEdge('‡∏ö‡∏•‡πá‡∏≠‡∏Å', '‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤');
  web.addEdge('‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠', '‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô');
  web.addEdge('‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô', '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠');

  final kosarajuStrategy = KosarajuAlgorithmStrategy<String>();
  final result = kosarajuStrategy.execute(SccInput(web));

  print('üîç ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Kosaraju SCC:');
  print('‡∏û‡∏ö ${result.componentCount} ‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏ô‡πà‡∏ô‡πÅ‡∏ü‡πâ‡∏ô:');
  for (int i = 0; i < result.components.length; i++) {
    print('  ‡∏Å‡∏•‡∏∏‡πà‡∏° ${i + 1}: {${result.components[i].join(', ')}}');
  }
}
```

#### Tarjan's Algorithm

```dart
void demonstrateTarjan() {
  // ‡∏Å‡∏£‡∏≤‡∏ü‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á Kosaraju
  final tarjanStrategy = TarjanAlgorithmStrategy<String>();
  final result = tarjanStrategy.execute(SccInput(web));

  print('‚ö° ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå Tarjan SCC:');
  print('‡∏û‡∏ö ${result.componentCount} ‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏ô‡πà‡∏ô‡πÅ‡∏ü‡πâ‡∏ô:');
  for (int i = 0; i < result.components.length; i++) {
    print('  ‡∏Å‡∏•‡∏∏‡πà‡∏° ${i + 1}: {${result.components[i].join(', ')}}');
  }
}
```

## üéÆ ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á

### 1. üó∫Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á GPS

```dart
class GPSNavigationSystem {
  final DijkstraAlgorithmStrategy<String> _dijkstra = DijkstraAlgorithmStrategy<String>();
  final BreadthFirstSearchStrategy<String> _bfs = BreadthFirstSearchStrategy<String>();

  /// ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏±‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏≠‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏µ‡πà
  NavigationResult findShortestRoute(Graph<String> roadNetwork, String start, String destination) {
    final result = _dijkstra.execute(DijkstraInput(roadNetwork, start));

    final distance = result.getDistance(destination);
    final path = result.getPath(destination);

    if (distance != null && path.isNotEmpty) {
      return NavigationResult.success(
        route: path,
        totalDistance: distance,
        estimatedTime: distance / 60, // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢ 60 ‡∏Å‡∏°./‡∏ä‡∏°.
      );
    } else {
      return NavigationResult.noRouteFound();
    }
  }

  /// ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏≤‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ BFS (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏à‡∏£‡∏≤‡∏à‡∏£)
  List<List<String>> findAlternativeRoutes(Graph<String> roadNetwork, String start, String destination) {
    // ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏∞‡πÉ‡∏ä‡πâ BFS ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏´‡∏•‡∏≤‡∏¢‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á
    // ‡∏ô‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏á‡πà‡∏≤‡∏¢
    final bfsResult = _bfs.execute(BfsInput(roadNetwork, start));
    return [bfsResult.getPath(destination)];
  }
}

class NavigationResult {
  final bool success;
  final List<String> route;
  final double totalDistance;
  final double estimatedTime;

  const NavigationResult({
    required this.success,
    this.route = const [],
    this.totalDistance = 0.0,
    this.estimatedTime = 0.0,
  });

  factory NavigationResult.success({required List<String> route, required double totalDistance, required double estimatedTime}) {
    return NavigationResult(success: true, route: route, totalDistance: totalDistance, estimatedTime: estimatedTime);
  }

  factory NavigationResult.noRouteFound() {
    return const NavigationResult(success: false);
  }
}
```

### 2. üì± ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏™‡∏±‡∏á‡∏Ñ‡∏°

```dart
class SocialNetworkAnalyzer {
  final BreadthFirstSearchStrategy<String> _bfs = BreadthFirstSearchStrategy<String>();
  final TarjanAlgorithmStrategy<String> _tarjan = TarjanAlgorithmStrategy<String>();

  /// ‡∏´‡∏≤‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏¢‡∏Å‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏ô‡∏™‡∏≠‡∏á‡∏Ñ‡∏ô
  int findDegreesOfSeparation(Graph<String> socialNetwork, String person1, String person2) {
    final bfsResult = _bfs.execute(BfsInput(socialNetwork, person1));
    return bfsResult.getDistance(person2) ?? -1; // -1 ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô
  }

  /// ‡∏´‡∏≤‡∏ä‡∏∏‡∏°‡∏ä‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¥‡∏ó‡∏ò‡∏¥‡∏û‡∏• (strongly connected components)
  List<Set<String>> findCommunities(Graph<String> socialNetwork) {
    final sccResult = _tarjan.execute(SccInput(socialNetwork));
    return sccResult.components.where((component) => component.length > 1).toList();
  }

  /// ‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ô
  Set<String> suggestMutualFriends(Graph<String> socialNetwork, String person) {
    final bfsResult = _bfs.execute(BfsInput(socialNetwork, person));
    final directFriends = socialNetwork.getEdges(person).map((e) => e.destination).toSet();

    final suggestions = <String>{};
    for (final friend in directFriends) {
      final friendsOfFriend = socialNetwork.getEdges(friend).map((e) => e.destination);
      suggestions.addAll(friendsOfFriend.where((f) => f != person && !directFriends.contains(f)));
    }

    return suggestions;
  }
}
```

### 3. üè¢ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏±‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£

```dart
class ProjectScheduler {
  final TopologicalSortStrategy<String> _topSort = TopologicalSortStrategy<String>();
  final DijkstraAlgorithmStrategy<String> _dijkstra = DijkstraAlgorithmStrategy<String>();

  /// ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡πÇ‡∏î‡∏¢‡πÄ‡∏Ñ‡∏≤‡∏£‡∏û dependencies
  ScheduleResult createSchedule(Graph<String> taskDependencies, Map<String, Duration> taskDurations) {
    final topSortResult = _topSort.execute(TopologicalSortInput(taskDependencies));

    if (!topSortResult.isValid) {
      return ScheduleResult.cyclicDependencies();
    }

    final schedule = <String, DateTime>{};
    var currentTime = DateTime.now();

    for (final task in topSortResult.sortedVertices) {
      schedule[task] = currentTime;
      currentTime = currentTime.add(taskDurations[task] ?? Duration.zero);
    }

    return ScheduleResult.success(
      taskOrder: topSortResult.sortedVertices,
      schedule: schedule,
      projectDuration: currentTime.difference(DateTime.now()),
    );
  }

  /// ‡∏´‡∏≤ critical path (‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏¢‡∏≤‡∏ß‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£)
  List<String> findCriticalPath(Graph<String> taskNetwork, Map<String, Duration> taskDurations) {
    // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô weighted graph ‡∏ó‡∏µ‡πà‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏Ñ‡∏∑‡∏≠‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏á‡∏≤‡∏ô
    final weightedNetwork = Graph<String>(isDirected: true, isWeighted: true);

    for (final vertex in taskNetwork.vertices) {
      weightedNetwork.addVertex(vertex);
    }

    for (final vertex in taskNetwork.vertices) {
      for (final edge in taskNetwork.getEdges(vertex)) {
        final duration = taskDurations[edge.destination]?.inHours.toDouble() ?? 0.0;
        weightedNetwork.addEdge(vertex, edge.destination, weight: duration);
      }
    }

    // ‡∏´‡∏≤ longest path (critical path) - ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ longest path algorithm
    // ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πâ topological order ‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì
    final topSortResult = _topSort.execute(TopologicalSortInput(taskNetwork));
    return topSortResult.sortedVertices;
  }
}

class ScheduleResult {
  final bool success;
  final List<String> taskOrder;
  final Map<String, DateTime> schedule;
  final Duration projectDuration;
  final String? errorMessage;

  const ScheduleResult({
    required this.success,
    this.taskOrder = const [],
    this.schedule = const {},
    this.projectDuration = Duration.zero,
    this.errorMessage,
  });

  factory ScheduleResult.success({
    required List<String> taskOrder,
    required Map<String, DateTime> schedule,
    required Duration projectDuration,
  }) {
    return ScheduleResult(
      success: true,
      taskOrder: taskOrder,
      schedule: schedule,
      projectDuration: projectDuration,
    );
  }

  factory ScheduleResult.cyclicDependencies() {
    return const ScheduleResult(
      success: false,
      errorMessage: '‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö cyclic dependencies ‡πÉ‡∏ô‡∏Å‡∏£‡∏≤‡∏ü‡∏á‡∏≤‡∏ô',
    );
  }
}
```

## ‚ö° ‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

### ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏à‡∏£‡∏¥‡∏á‡∏Å‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏£‡∏≤‡∏ü‡∏ï‡πà‡∏≤‡∏á‡πÜ:

| ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°      | ‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏£‡∏≤‡∏ü | ‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î | ‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° | ‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô | Throughput |
| --------------- | -------- | ------ | ---------- | ------------ | ---------- |
| **BFS**         | ‡πÄ‡∏•‡πá‡∏Å     | 100    | 200        | 0.15ms       | 667K V/s   |
| **BFS**         | ‡∏Å‡∏•‡∏≤‡∏á     | 1,000  | 2,000      | 1.2ms        | 833K V/s   |
| **BFS**         | ‡πÉ‡∏´‡∏ç‡πà     | 10,000 | 20,000     | 12ms         | 833K V/s   |
| **DFS**         | ‡πÄ‡∏•‡πá‡∏Å     | 100    | 200        | 0.12ms       | 833K V/s   |
| **DFS**         | ‡∏Å‡∏•‡∏≤‡∏á     | 1,000  | 2,000      | 1.0ms        | 1M V/s     |
| **DFS**         | ‡πÉ‡∏´‡∏ç‡πà     | 10,000 | 20,000     | 10ms         | 1M V/s     |
| **Dijkstra**    | ‡πÄ‡∏•‡πá‡∏Å     | 100    | 200        | 0.8ms        | 125K V/s   |
| **Dijkstra**    | ‡∏Å‡∏•‡∏≤‡∏á     | 1,000  | 2,000      | 8ms          | 125K V/s   |
| **Dijkstra**    | ‡πÉ‡∏´‡∏ç‡πà     | 10,000 | 20,000     | 85ms         | 118K V/s   |
| **Prim MST**    | ‡πÄ‡∏•‡πá‡∏Å     | 100    | 200        | 0.6ms        | 167K V/s   |
| **Prim MST**    | ‡∏Å‡∏•‡∏≤‡∏á     | 1,000  | 2,000      | 6ms          | 167K V/s   |
| **Kruskal MST** | ‡πÄ‡∏•‡πá‡∏Å     | 100    | 200        | 0.9ms        | 111K V/s   |
| **Kruskal MST** | ‡∏Å‡∏•‡∏≤‡∏á     | 1,000  | 2,000      | 9ms          | 111K V/s   |

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥

| ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°     | Space Complexity | ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 10K ‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î |
| -------------- | ---------------- | ---------------------------- |
| BFS/DFS        | O(V)             | ~40KB                        |
| Dijkstra       | O(V)             | ~40KB                        |
| Floyd-Warshall | O(V¬≤)            | ~400MB                       |
| Prim's MST     | O(V)             | ~40KB                        |
| Kruskal's MST  | O(V + E)         | ~80KB                        |

### ‡πÄ‡∏Ñ‡∏•‡πá‡∏î‡∏•‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û

1. **‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°**:

   - ‡πÉ‡∏ä‡πâ BFS ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö unweighted shortest paths
   - ‡πÉ‡∏ä‡πâ Dijkstra ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö weighted shortest paths ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡∏¥‡∏î‡∏•‡∏ö
   - ‡πÉ‡∏ä‡πâ Bellman-Ford ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡πÑ‡∏î‡πâ

2. **‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏£‡∏≤‡∏ü**:

   - AlgoMate ‡πÉ‡∏ä‡πâ adjacency lists (‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö sparse graphs)
   - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö dense graphs ‡∏°‡∏≤‡∏Å (E ‚âà V¬≤), adjacency matrix ‡∏≠‡∏≤‡∏à‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤

3. **‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥**:
   - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏≤‡∏ü‡πÉ‡∏´‡∏ç‡πà, ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Dijkstra ‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ Floyd-Warshall
   - ‡πÉ‡∏ä‡πâ streaming algorithms ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏£‡∏≤‡∏ü‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥

## üß™ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö

### ‡∏ä‡∏∏‡∏î‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°

AlgoMate ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:

```dart
void runGraphAlgorithmTests() {
  group('‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph', () {
    test('BFS ‡∏´‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÉ‡∏ô unweighted graph', () {
      final graph = Graph<int>(isDirected: false);
      [1, 2, 3, 4, 5].forEach(graph.addVertex);

      graph.addEdge(1, 2);
      graph.addEdge(1, 3);
      graph.addEdge(2, 4);
      graph.addEdge(3, 5);
      graph.addEdge(4, 5);

      final bfsStrategy = BreadthFirstSearchStrategy<int>();
      final result = bfsStrategy.execute(BfsInput(graph, 1));

      expect(result.getDistance(5), equals(2));
      expect(result.getPath(5), equals([1, 3, 5]));
    });

    test('Dijkstra ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ weighted graphs ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á', () {
      final graph = Graph<String>(isDirected: true, isWeighted: true);
      ['A', 'B', 'C', 'D'].forEach(graph.addVertex);

      graph.addEdge('A', 'B', weight: 10);
      graph.addEdge('A', 'C', weight: 3);
      graph.addEdge('B', 'D', weight: 2);
      graph.addEdge('C', 'D', weight: 8);

      final dijkstraStrategy = DijkstraAlgorithmStrategy<String>();
      final result = dijkstraStrategy.execute(DijkstraInput(graph, 'A'));

      expect(result.getDistance('D'), equals(11)); // A -> C -> D = 3 + 8 = 11
    });

    test('Topological sort ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö cycles', () {
      final graph = Graph<String>(isDirected: true);
      ['A', 'B', 'C'].forEach(graph.addVertex);

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á cycle: A -> B -> C -> A
      graph.addEdge('A', 'B');
      graph.addEdge('B', 'C');
      graph.addEdge('C', 'A');

      final topSortStrategy = TopologicalSortStrategy<String>();
      final result = topSortStrategy.execute(TopologicalSortInput(graph));

      expect(result.isValid, isFalse);
    });

    test('‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° MST ‡πÉ‡∏´‡πâ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏£‡∏ß‡∏°‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ô', () {
      final graph = Graph<int>(isDirected: false, isWeighted: true);
      [1, 2, 3, 4].forEach(graph.addVertex);

      graph.addEdge(1, 2, weight: 10);
      graph.addEdge(1, 3, weight: 15);
      graph.addEdge(2, 3, weight: 5);
      graph.addEdge(2, 4, weight: 20);
      graph.addEdge(3, 4, weight: 8);

      final primStrategy = PrimAlgorithmStrategy<int>();
      final kruskalStrategy = KruskalAlgorithmStrategy<int>();

      final primResult = primStrategy.execute(MstInput(graph));
      final kruskalResult = kruskalStrategy.execute(MstInput(graph));

      expect(primResult.totalWeight, equals(kruskalResult.totalWeight));
      expect(primResult.totalWeight, equals(23)); // 5 + 8 + 10 = 23
    });
  });
}
```

### ‡∏Å‡∏£‡∏ì‡∏µ‡∏Ç‡πâ‡∏≠‡∏ö‡∏Å‡∏û‡∏£‡πà‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö

```dart
void validateGraphAlgorithms() {
  // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏±‡∏ö‡∏Å‡∏£‡∏≤‡∏ü‡∏ß‡πà‡∏≤‡∏á
  final emptyGraph = Graph<String>(isDirected: false);

  // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
  final singleVertex = Graph<String>(isDirected: false);
  singleVertex.addVertex('A');

  // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏±‡∏ö components ‡∏ó‡∏µ‡πà‡πÅ‡∏¢‡∏Å‡∏Å‡∏±‡∏ô
  final disconnected = Graph<String>(isDirected: false);
  ['A', 'B', 'C', 'D'].forEach(disconnected.addVertex);
  disconnected.addEdge('A', 'B');
  disconnected.addEdge('C', 'D'); // Component ‡πÅ‡∏¢‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏≤‡∏Å

  // ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ñ‡∏ß‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
  // ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
}
```

## üéì ‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡∏õ‡∏è‡∏¥‡∏ö‡∏±‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏î‡∏µ

### 1. **‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°**

```dart
class GraphAlgorithmSelector {
  static Strategy<BfsInput<T>, BfsResult<T>> selectTraversalAlgorithm<T>(
    GraphCharacteristics characteristics
  ) {
    if (characteristics.needsShortestPath && !characteristics.isWeighted) {
      return BreadthFirstSearchStrategy<T>();
    } else if (characteristics.needsPathEnumeration || characteristics.hasCycles) {
      return DepthFirstSearchStrategy<T>();
    } else {
      return BreadthFirstSearchStrategy<T>(); // Default ‡πÉ‡∏ä‡πâ BFS
    }
  }

  static Strategy selectShortestPathAlgorithm<T>(
    GraphCharacteristics characteristics
  ) {
    if (characteristics.hasNegativeWeights) {
      return BellmanFordAlgorithmStrategy<T>();
    } else if (characteristics.needsAllPairs) {
      return FloydWarshallAlgorithmStrategy<T>();
    } else {
      return DijkstraAlgorithmStrategy<T>();
    }
  }
}

class GraphCharacteristics {
  final bool isWeighted;
  final bool isDirected;
  final bool hasNegativeWeights;
  final bool needsShortestPath;
  final bool needsAllPairs;
  final bool needsPathEnumeration;
  final bool hasCycles;

  const GraphCharacteristics({
    required this.isWeighted,
    required this.isDirected,
    this.hasNegativeWeights = false,
    this.needsShortestPath = false,
    this.needsAllPairs = false,
    this.needsPathEnumeration = false,
    this.hasCycles = false,
  });
}
```

### 2. **‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î**

```dart
void safeGraphProcessing<T>(Graph<T> graph, T startVertex) {
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö inputs
  if (!graph.vertices.contains(startVertex)) {
    throw ArgumentError('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏ô‡∏Å‡∏£‡∏≤‡∏ü');
  }

  // ‡πÉ‡∏ä‡πâ try-catch ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ô‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°
  try {
    final bfsStrategy = BreadthFirstSearchStrategy<T>();
    final result = bfsStrategy.execute(BfsInput(graph, startVertex));

    // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
    processResults(result);
  } catch (e) {
    print('‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: $e');
    // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
  }
}

void processResults<T>(BfsResult<T> result) {
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏™‡∏°‡∏≠‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡∏ñ‡∏π‡∏Å‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  for (final vertex in graph.vertices) {
    final distance = result.getDistance(vertex);
    if (distance != null) {
      print('‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î $vertex ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á $distance');
    } else {
      print('‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î $vertex ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏î‡πâ');
    }
  }
}
```

### 3. **‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û**

```dart
class OptimizedGraphProcessor<T> {
  // ‡πÅ‡∏Ñ‡∏ä strategies ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ö‡πà‡∏≠‡∏¢
  late final BreadthFirstSearchStrategy<T> _bfsStrategy;
  late final DijkstraAlgorithmStrategy<T> _dijkstraStrategy;

  OptimizedGraphProcessor() {
    _bfsStrategy = BreadthFirstSearchStrategy<T>();
    _dijkstraStrategy = DijkstraAlgorithmStrategy<T>();
  }

  // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏•‡∏≤‡∏¢ queries ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û
  Map<T, BfsResult<T>> batchBFS(Graph<T> graph, List<T> startVertices) {
    final results = <T, BfsResult<T>>{};

    for (final start in startVertices) {
      if (graph.vertices.contains(start)) {
        results[start] = _bfsStrategy.execute(BfsInput(graph, start));
      }
    }

    return results;
  }

  // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ö‡πà‡∏≠‡∏¢‡πÑ‡∏ß‡πâ‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤
  void precomputeDistances(Graph<T> graph, T centralVertex) {
    final result = _dijkstraStrategy.execute(DijkstraInput(graph, centralVertex));
    // ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏†‡∏≤‡∏¢‡∏´‡∏•‡∏±‡∏á
    _distanceCache[centralVertex] = result;
  }

  final Map<T, DijkstraResult<T>> _distanceCache = {};
}
```

---

## üöÄ ‡∏ö‡∏ó‡∏™‡∏£‡∏∏‡∏õ

‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡∏Ç‡∏≠‡∏á AlgoMate ‡∏°‡∏≠‡∏ö **‡πÇ‡∏ã‡∏•‡∏π‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡πÅ‡∏•‡∏∞‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡πÉ‡∏ô production** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Graph ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏≥‡∏ó‡∏≤‡∏á GPS, ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏™‡∏±‡∏á‡∏Ñ‡∏°, ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢ AlgoMate ‡∏°‡∏µ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°

### ‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç:

- ‚úÖ **‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° 10+** ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏Å‡∏£‡∏ì‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Graph ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- ‚úÖ **Time complexities ‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á O(V + E) ‡∏ñ‡∏∂‡∏á O(V¬≥)** ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
- ‚úÖ **‡∏Å‡∏≤‡∏£‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö Generic** ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏Å‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡πÉ‡∏î‡∏Å‡πá‡πÑ‡∏î‡πâ
- ‚úÖ **‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢** ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°
- ‚úÖ **‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏ô Production** ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°
- ‚úÖ **‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡∏á‡πà‡∏≤‡∏¢** ‡∏Å‡∏±‡∏ö Strategy pattern ‡∏Ç‡∏≠‡∏á AlgoMate

‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° Graph ‡∏Ç‡∏≠‡∏á AlgoMate ‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Graph ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡πÑ‡∏õ‡∏™‡∏π‡πà‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏á‡πà‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏ó‡∏£‡∏á‡∏û‡∏•‡∏±‡∏á!

üìñ **‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á:**

- [‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠ Custom Objects](CUSTOM_OBJECTS_GUIDE.md) - ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° graph ‡∏Å‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏à‡∏∏‡∏î‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á
- [README ‡∏´‡∏•‡∏±‡∏Å](README.md) - ‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£ AlgoMate ‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
- [‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á](example/graph_algorithms_example.dart) - ‡∏Å‡∏≤‡∏£‡∏™‡∏≤‡∏ò‡∏¥‡∏ï‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏±‡∏ô‡πÑ‡∏î‡πâ

---

_‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠ AlgoMate Graph Algorithms - ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• Graph ‡∏Ç‡∏±‡πâ‡∏ô‡∏™‡∏π‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÑ‡∏î‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô_ üåê
